# -*- coding: utf-8 -*-
import discord
from discord.ext import tasks
from discord import app_commands
import json
import os
import shutil
import asyncio
import logging
import functools
from datetime import datetime, timezone, timedelta

# ====================== åŸºæœ¬è¨­å®š ======================
DEBUG = False

DATA_FILE = "roles_data.json"
SETTINGS_FILE = "bot_settings_debug.json" if DEBUG else "bot_settings.json"
BACKUP_DIR = "backup"

JST = timezone(timedelta(hours=9))
now_jst = lambda: datetime.now(JST)
timestamp_to_jst = lambda ts: datetime.fromtimestamp(ts, JST)

CHECK_INTERVAL = 10 if DEBUG else 600
SYNC_INTERVAL = 15 if DEBUG else 3600
BATCH_SIZE = 20 if DEBUG else 50
API_DELAY = 0.5 if DEBUG else 0.2
ROLES_TO_AUTO_REMOVE = ["æ³¨æ„", "è­¦å‘Š"]
DEFAULT_REMOVE_SECONDS = {
    "æ³¨æ„": 15 if DEBUG else 90 * 86400,
    "è­¦å‘Š": 15 if DEBUG else 90 * 86400
}

LOG_CHANNEL_NAME, LOG_CHANNEL_ID = "bot-logs", None

# ãƒ­ã‚®ãƒ³ã‚°è¨­å®š
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',
                   handlers=[logging.FileHandler('bot.log', encoding='utf-8'), logging.StreamHandler()])
logger = logging.getLogger(__name__)

def format_duration(seconds: float) -> str:
    """ç§’æ•°ã‚’é©åˆ‡ãªå˜ä½ã§æ–‡å­—åˆ—åŒ–"""
    seconds = int(seconds)
    if seconds < 60:
        return f"{seconds}ç§’"
    elif seconds < 3600:
        return f"{seconds // 60}åˆ†{seconds % 60}ç§’" if seconds % 60 else f"{seconds // 60}åˆ†"
    elif seconds < 86400:
        min_ = (seconds % 3600) // 60
        sec_ = seconds % 60
        return f"{seconds // 3600}æ™‚é–“{min_}åˆ†{sec_}ç§’" if min_ or sec_ else f"{seconds // 3600}æ™‚é–“"
    else:
        hr_ = (seconds % 86400) // 3600
        min_ = (seconds % 3600) // 60
        sec_ = seconds % 60
        val = f"{seconds // 86400}æ—¥"
        if hr_ or min_ or sec_:
            val += f"{hr_}æ™‚é–“" if hr_ else ""
            val += f"{min_}åˆ†" if min_ else ""
            val += f"{sec_}ç§’" if sec_ else ""
        return val

def parse_duration(days=0, hours=0, minutes=0, seconds=0):
    """å„å˜ä½ã‹ã‚‰åˆè¨ˆç§’æ•°ã‚’å¾—ã‚‹"""
    return int(days) * 86400 + int(hours) * 3600 + int(minutes) * 60 + int(seconds)

class DataManager:
    def __init__(self):
        self.role_data = {}
        self.settings = {}
        self._lock = asyncio.Lock()
        self.load_all()
    
    def load_all(self):
        """ãƒ‡ãƒ¼ã‚¿ã¨è¨­å®šã‚’èª­ã¿è¾¼ã¿"""
        self.role_data = self._load_json(DATA_FILE, {})
        self.settings = self._load_json(SETTINGS_FILE, {"remove_seconds": DEFAULT_REMOVE_SECONDS.copy()})

        # è¨­å®šã®è£œå®Œ
        if "remove_seconds" not in self.settings:
            self.settings["remove_seconds"] = DEFAULT_REMOVE_SECONDS.copy()
        for role in ROLES_TO_AUTO_REMOVE:
            if role not in self.settings["remove_seconds"]:
                self.settings["remove_seconds"][role] = DEFAULT_REMOVE_SECONDS[role]
    
    def _load_json(self, file_path, default):
        """JSONãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿"""
        if not os.path.exists(file_path):
            self._save_json(file_path, default)
            return default
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error loading {file_path}: {e}")
            return default
    
    def _save_json(self, file_path, data):
        """JSONãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜"""
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"Error saving {file_path}: {e}")
    
    async def save_all(self):
        """å…¨ãƒ‡ãƒ¼ã‚¿ä¿å­˜"""
        async with self._lock:
            self._backup_data()
            self._save_json(DATA_FILE, self.role_data)
            self._save_json(SETTINGS_FILE, self.settings)
    
    def _backup_data(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—"""
        os.makedirs(BACKUP_DIR, exist_ok=True)
        if os.path.exists(DATA_FILE):
            timestamp = now_jst().strftime("%Y%m%d_%H%M%S")
            backup_path = os.path.join(BACKUP_DIR, f"roles_data_{timestamp}.json")
            shutil.copy2(DATA_FILE, backup_path)
            self._cleanup_old_backups()
    
    def _cleanup_old_backups(self):
        """å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‰Šé™¤"""
        try:
            backups = sorted([f for f in os.listdir(BACKUP_DIR) if f.startswith("roles_data_")], reverse=True)
            for old_backup in backups[10:]:
                os.remove(os.path.join(BACKUP_DIR, old_backup))
        except Exception as e:
            logger.error(f"Backup cleanup error: {e}")
    
    def get_remove_seconds(self, guild_id, user_id, role_name):
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼å€‹äººã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‰Šé™¤æœŸé–“å–å¾—ï¼ˆç§’ï¼‰"""
        # å€‹äººè¨­å®šãƒã‚§ãƒƒã‚¯
        if ("user_remove_seconds" in self.settings and 
            guild_id in self.settings["user_remove_seconds"] and 
            user_id in self.settings["user_remove_seconds"][guild_id] and 
            role_name in self.settings["user_remove_seconds"][guild_id][user_id]):
            return self.settings["user_remove_seconds"][guild_id][user_id][role_name]
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
        return self.settings["remove_seconds"].get(role_name, DEFAULT_REMOVE_SECONDS.get(role_name, 90 * 86400))
    
    def set_user_remove_seconds(self, guild_id, user_id, role_name, seconds):
        """å€‹äººå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç§’ï¼‰"""
        if "user_remove_seconds" not in self.settings:
            self.settings["user_remove_seconds"] = {}
        if guild_id not in self.settings["user_remove_seconds"]:
            self.settings["user_remove_seconds"][guild_id] = {}
        if user_id not in self.settings["user_remove_seconds"][guild_id]:
            self.settings["user_remove_seconds"][guild_id][user_id] = {}
        
        self.settings["user_remove_seconds"][guild_id][user_id][role_name] = seconds
    
    def remove_user_setting(self, guild_id, user_id, role_name):
        """å€‹äººè¨­å®šå‰Šé™¤"""
        try:
            if (self.settings.get("user_remove_seconds", {}).get(guild_id, {})
                .get(user_id, {}).get(role_name)):
                del self.settings["user_remove_seconds"][guild_id][user_id][role_name]
                
                # ç©ºã®ãƒã‚¹ãƒˆã‚’å‰Šé™¤
                if not self.settings["user_remove_seconds"][guild_id][user_id]:
                    del self.settings["user_remove_seconds"][guild_id][user_id]
                if not self.settings["user_remove_seconds"][guild_id]:
                    del self.settings["user_remove_seconds"][guild_id]
                if not self.settings["user_remove_seconds"]:
                    del self.settings["user_remove_seconds"]
                return True
        except KeyError:
            pass
        return False

intents = discord.Intents.default()
intents.members = True
intents.message_content = True

class RoleBot(discord.Client):
    def __init__(self):
        super().__init__(intents=intents)
        self.tree = app_commands.CommandTree(self)
        self.data = DataManager()
        self.removal_lock = asyncio.Lock()  # ãƒ­ãƒ¼ãƒ«å‰Šé™¤ç”¨ãƒ­ãƒƒã‚¯
    
    async def setup_hook(self):
        await self._sync_commands()
    
    async def _sync_commands(self):
        """ã‚³ãƒãƒ³ãƒ‰åŒæœŸ"""
        try:
            synced = await self.tree.sync()
            logger.info(f"Synced {len(synced)} commands globally")
            for guild in self.guilds:
                self.tree.copy_global_to(guild=guild)
                synced = await self.tree.sync(guild=guild)
                logger.info(f"Synced {len(synced)} commands to {guild.name}")
        except Exception as e:
            logger.error(f"Command sync error: {e}")

bot = RoleBot()

async def log_message(guild, message, level="info"):
    """ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡"""
    try:
        channel = None
        if LOG_CHANNEL_ID:
            channel = guild.get_channel(LOG_CHANNEL_ID)
        elif LOG_CHANNEL_NAME:
            channel = discord.utils.get(guild.text_channels, name=LOG_CHANNEL_NAME)
        
        if channel:
            emoji_map = {"info": "â„¹ï¸", "success": "âœ…", "warning": "âš ï¸", "error": "âŒ"}
            emoji = emoji_map.get(level, "ğŸ“")
            await channel.send(f"{emoji} {message}"[:2000])
    except Exception as e:
        logger.error(f"Discord log error: {e}")
    
    # ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°
    log_text = f"[{guild.name}] {message}"
    getattr(logger, level if level != "success" else "info")(log_text)

async def add_role_with_timestamp(member, role, silent=False, reason=None):
    """ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãï¼‰"""
    try:
        guild_id, user_id = str(member.guild.id), str(member.id)
        
        # ãƒ‡ãƒ¼ã‚¿æ§‹é€ åˆæœŸåŒ–
        if guild_id not in bot.data.role_data:
            bot.data.role_data[guild_id] = {}
        if user_id not in bot.data.role_data[guild_id]:
            bot.data.role_data[guild_id][user_id] = {}
        
        if role in member.roles:
            return True
        
        # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²
        if role.name not in bot.data.role_data[guild_id][user_id]:
            bot.data.role_data[guild_id][user_id][role.name] = now_jst().timestamp()
        
        await member.add_roles(role, reason=reason or ("è‡ªå‹•ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆé™éŸ³ï¼‰" if silent else "è‡ªå‹•ãƒ­ãƒ¼ãƒ«ä»˜ä¸"))
        await bot.data.save_all()
        return True
    except Exception as e:
        logger.error(f"Role add error for {member}: {e}")
        return False

async def sync_data_with_reality(guild, is_periodic=False):
    """ãƒ‡ãƒ¼ã‚¿åŒæœŸ"""
    try:
        now = now_jst().timestamp()
        guild_id = str(guild.id)
        
        if guild_id not in bot.data.role_data:
            bot.data.role_data[guild_id] = {}
        
        current_holders = {}
        for member in guild.members:
            if member.bot:
                continue
            user_id = str(member.id)
            for role in member.roles:
                if role.name in ROLES_TO_AUTO_REMOVE:
                    current_holders.setdefault(user_id, []).append(role.name)
        
        changes = {"removed": 0, "added": 0}
        
        users_to_remove = []
        for user_id, user_roles in list(bot.data.role_data[guild_id].items()):
            if user_id not in current_holders:
                users_to_remove.append(user_id)
                changes["removed"] += len(user_roles)
            else:
                for role_name in list(user_roles.keys()):
                    if role_name not in current_holders[user_id]:
                        del bot.data.role_data[guild_id][user_id][role_name]
                        changes["removed"] += 1
                if not bot.data.role_data[guild_id][user_id]:
                    users_to_remove.append(user_id)
        
        for user_id in users_to_remove:
            del bot.data.role_data[guild_id][user_id]
        
        for user_id, roles in current_holders.items():
            if user_id not in bot.data.role_data[guild_id]:
                bot.data.role_data[guild_id][user_id] = {}
            for role_name in roles:
                if role_name not in bot.data.role_data[guild_id][user_id]:
                    bot.data.role_data[guild_id][user_id][role_name] = now
                    changes["added"] += 1
        
        if changes["removed"] or changes["added"]:
            await bot.data.save_all()
            sync_msg = f"{'å®šæœŸ' if is_periodic else 'èµ·å‹•æ™‚'}åŒæœŸ: å‰Šé™¤{changes['removed']}ä»¶, è¿½åŠ {changes['added']}ä»¶"
            if is_periodic and (changes["removed"] or changes["added"]):
                await log_message(guild, sync_msg, "info")
            elif not is_periodic:
                await log_message(guild, sync_msg, "info")
        
        return changes
    except Exception as e:
        logger.error(f"Sync error for {guild.name}: {e}")
        return {"removed": 0, "added": 0}

async def process_role_removal(guild):
    """ãƒ­ãƒ¼ãƒ«å‰Šé™¤å‡¦ç†"""
    guild_id = str(guild.id)
    if guild_id not in bot.data.role_data:
        return 0
    
    now = now_jst().timestamp()
    total_removed = 0

    # æ’ä»–åˆ¶å¾¡ã§åŒæ™‚å®Ÿè¡Œé˜²æ­¢
    async with bot.removal_lock:
        for user_id, user_roles in list(bot.data.role_data[guild_id].items()):
            member = guild.get_member(int(user_id))
            if not member:
                del bot.data.role_data[guild_id][user_id]
                continue
            
            roles_to_remove = []
            for role_name, timestamp in list(user_roles.items()):
                if role_name not in ROLES_TO_AUTO_REMOVE or not timestamp:
                    continue
                
                role = discord.utils.get(guild.roles, name=role_name)
                if not role or role not in member.roles:
                    bot.data.role_data[guild_id][user_id].pop(role_name, None)
                    continue
                
                remove_seconds = bot.data.get_remove_seconds(guild_id, user_id, role_name)
                if now - timestamp >= remove_seconds:
                    roles_to_remove.append((role, role_name, remove_seconds, timestamp))
            
            for role, role_name, remove_seconds, timestamp in roles_to_remove:
                try:
                    # å¿µã®ãŸã‚ç›´å‰ã«ãƒ­ãƒ¼ãƒ«ãŒæ®‹ã£ã¦ã‚‹ã‹ç¢ºèª
                    if role not in member.roles:
                        continue
                    await member.remove_roles(role, reason=f"è‡ªå‹•å‰Šé™¤ï¼ˆ{format_duration(remove_seconds)}çµŒéï¼‰")
                    assigned_time = timestamp_to_jst(timestamp)
                    sec_passed = int(now - timestamp)
                    await log_message(
                        guild,
                        f"{member.display_name} ã‹ã‚‰ '{role_name}' ã‚’è‡ªå‹•å‰Šé™¤ "
                        f"(ä»˜ä¸: {assigned_time.strftime('%Y/%m/%d %H:%M:%S')}, çµŒé: {format_duration(sec_passed)})",
                        "success"
                    )
                    
                    bot.data.role_data[guild_id][user_id].pop(role_name, None)
                    total_removed += 1
                    await bot.data.save_all()
                    await asyncio.sleep(0.1)
                except Exception as e:
                    logger.error(f"Role removal error for {member}: {e}")
            
            if not bot.data.role_data[guild_id][user_id]:
                del bot.data.role_data[guild_id][user_id]
    
    return total_removed

@tasks.loop(seconds=CHECK_INTERVAL)
async def check_roles():
    """å®šæœŸãƒ­ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯"""
    try:
        total_removed = 0
        for guild in bot.guilds:
            removed = await process_role_removal(guild)
            total_removed += removed
            await asyncio.sleep(API_DELAY)
        
        await bot.data.save_all()
        if total_removed:
            logger.info(f"Role check completed - Removed: {total_removed}")
    except Exception as e:
        logger.error(f"Role check error: {e}")

@tasks.loop(seconds=SYNC_INTERVAL)
async def sync_data_periodically():
    """å®šæœŸãƒ‡ãƒ¼ã‚¿åŒæœŸ"""
    try:
        for guild in bot.guilds:
            await sync_data_with_reality(guild, True)
            await asyncio.sleep(1)
        await bot.data.save_all()
    except Exception as e:
        logger.error(f"Periodic sync error: {e}")

@check_roles.before_loop
@sync_data_periodically.before_loop
async def wait_until_ready():
    await bot.wait_until_ready()

@bot.event
async def on_ready():
    logger.info(f"Logged in as {bot.user} - {len(bot.guilds)} guilds")
    
    for guild in bot.guilds:
        await log_message(guild, f"Botèµ·å‹•å®Œäº† ({now_jst().strftime('%Y/%m/%d %H:%M:%S')} JST)", "success")
        await sync_data_with_reality(guild)
    
    await bot.data.save_all()
    
    if not check_roles.is_running():
        check_roles.start()
    if not sync_data_periodically.is_running():
        sync_data_periodically.start()
    
    await check_roles.coro()

def admin_required(func):
    """ç®¡ç†è€…æ¨©é™ãƒã‚§ãƒƒã‚¯ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"""
    @functools.wraps(func)
    async def wrapper(interaction, *args, **kwargs):
        if not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("âŒ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚", ephemeral=True)
            return
        return await func(interaction, *args, **kwargs)
    return wrapper

async def create_embed(title, color=0x0099ff, **fields):
    """Embedä½œæˆãƒ˜ãƒ«ãƒ‘ãƒ¼"""
    embed = discord.Embed(title=title, color=color)
    for name, value in fields.items():
        embed.add_field(name=name.replace('_', ' ').title(), value=value, inline=True)
    return embed

@bot.tree.command(name="giveall", description="å…¨å“¡ã«æŒ‡å®šãƒ­ãƒ¼ãƒ«ã‚’ä»˜ä¸")
@app_commands.describe(role="ä»˜ä¸ã™ã‚‹ãƒ­ãƒ¼ãƒ«", silent="é™éŸ³ãƒ¢ãƒ¼ãƒ‰")
async def giveall(interaction: discord.Interaction, role: discord.Role, silent: bool = False):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("âŒ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚", ephemeral=True)
        return
    
    if role >= interaction.guild.me.top_role:
        await interaction.response.send_message("âŒ ãã®ãƒ­ãƒ¼ãƒ«ã¯ä»˜ä¸ã§ãã¾ã›ã‚“", ephemeral=True)
        return
    
    await interaction.response.defer(thinking=True)
    
    members = [m for m in interaction.guild.members if not m.bot and role not in m.roles]
    if not members:
        await interaction.followup.send("âœ… å…¨å“¡ãŒæ—¢ã«ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã¾ã™ã€‚")
        return
    
    progress_msg = await interaction.followup.send(f"ğŸ”„ {role.name} ã‚’ {len(members)} äººã«ä»˜ä¸ä¸­...")
    
    success = 0
    for i, member in enumerate(members):
        if await add_role_with_timestamp(member, role, silent, f"ä¸€æ‹¬ä»˜ä¸ by {interaction.user.display_name}"):
            success += 1
        
        if (i + 1) % BATCH_SIZE == 0:
            await progress_msg.edit(content=f"ğŸ”„ é€²è¡ŒçŠ¶æ³: {i + 1}/{len(members)}")
            await asyncio.sleep(API_DELAY)
        else:
            await asyncio.sleep(0.1)
    
    result = f"âœ… {role.name} ä»˜ä¸å®Œäº†ï¼æˆåŠŸ: {success}äºº"
    if role.name in ROLES_TO_AUTO_REMOVE:
        seconds = bot.data.settings["remove_seconds"].get(role.name, DEFAULT_REMOVE_SECONDS[role.name])
        result += f"\nâ° {format_duration(seconds)}å¾Œã«è‡ªå‹•å‰Šé™¤"
    
    await progress_msg.edit(content=result)
    await log_message(interaction.guild, f"{interaction.user.display_name} ãŒ {role.name} ã‚’ä¸€æ‹¬ä»˜ä¸: {success}äºº", "success")

@bot.tree.command(name="test_add", description="è‡ªåˆ†ã«ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰")
@app_commands.describe(role="ä»˜ä¸ã™ã‚‹ãƒ­ãƒ¼ãƒ«", silent="é™éŸ³ãƒ¢ãƒ¼ãƒ‰")
async def test_add(interaction: discord.Interaction, role: discord.Role, silent: bool = False):
    if role >= interaction.guild.me.top_role:
        await interaction.response.send_message("âŒ ãã®ãƒ­ãƒ¼ãƒ«ã¯ä»˜ä¸ã§ãã¾ã›ã‚“", ephemeral=True)
        return
    
    if role in interaction.user.roles:
        await interaction.response.send_message(f"â„¹ï¸ æ—¢ã« {role.name} ã‚’æŒã£ã¦ã„ã¾ã™", ephemeral=True)
        return
    
    result = await add_role_with_timestamp(interaction.user, role, silent, "ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰")
    if result:
        msg = f"âœ… {role.name} ã‚’ä»˜ä¸ã—ã¾ã—ãŸ"
        if role.name in ROLES_TO_AUTO_REMOVE:
            seconds = bot.data.get_remove_seconds(str(interaction.guild.id), str(interaction.user.id), role.name)
            msg += f"\nâ° {format_duration(seconds)}å¾Œã«è‡ªå‹•å‰Šé™¤"
        await interaction.response.send_message(msg)
    else:
        await interaction.response.send_message("âŒ ä»˜ä¸ã«å¤±æ•—ã—ã¾ã—ãŸ", ephemeral=True)

@bot.tree.command(name="status", description="BotçŠ¶æ…‹è¡¨ç¤º")
async def status(interaction: discord.Interaction):
    guild_id = str(interaction.guild.id)
    tracked = len(bot.data.role_data.get(guild_id, {}))
    
    embed = await create_embed(
        "Bot ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", 0x00ff00,
        è¿½è·¡ä¸­ãƒ¦ãƒ¼ã‚¶ãƒ¼=f"{tracked}äºº",
        ãƒã‚§ãƒƒã‚¯é–“éš”=f"{CHECK_INTERVAL//60}åˆ†",
        åŒæœŸé–“éš”=f"{SYNC_INTERVAL//60}åˆ†",
        ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³="æ—¥æœ¬æ™‚é–“ (JST)"
    )
    
    remove_info = []
    for role in ROLES_TO_AUTO_REMOVE:
        seconds = bot.data.settings["remove_seconds"].get(role, DEFAULT_REMOVE_SECONDS[role])
        remove_info.append(f"{role}: {format_duration(seconds)}")
    embed.add_field(name="è‡ªå‹•å‰Šé™¤æœŸé–“", value="\n".join(remove_info), inline=False)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="set_remove_period", description="ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰")
@app_commands.describe(
    role="ãƒ­ãƒ¼ãƒ«å", 
    days="æ—¥", 
    hours="æ™‚é–“", 
    minutes="åˆ†", 
    seconds="ç§’"
)
@app_commands.choices(role=[app_commands.Choice(name=r, value=r) for r in ROLES_TO_AUTO_REMOVE])
@admin_required
async def set_remove_period(
    interaction: discord.Interaction, 
    role: str, 
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0
):
    total_seconds = parse_duration(days, hours, minutes, seconds)
    if total_seconds < 0:
        await interaction.response.send_message("âŒ æœŸé–“ã¯0ä»¥ä¸Šã§æŒ‡å®šã—ã¦ãã ã•ã„", ephemeral=True)
        return
    
    old_seconds = bot.data.settings["remove_seconds"].get(role, DEFAULT_REMOVE_SECONDS[role])
    bot.data.settings["remove_seconds"][role] = total_seconds
    await bot.data.save_all()
    
    embed = await create_embed(
        "âœ… ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‰Šé™¤æœŸé–“è¨­å®šå®Œäº†", 0x00ff00,
        ãƒ­ãƒ¼ãƒ«=role, 
        å¤‰æ›´å‰=format_duration(old_seconds),
        å¤‰æ›´å¾Œ=format_duration(total_seconds)
    )
    await interaction.response.send_message(embed=embed)
    await log_message(interaction.guild, f"{interaction.user.display_name} ãŒ '{role}' æœŸé–“ã‚’ {format_duration(old_seconds)}â†’{format_duration(total_seconds)}ã«å¤‰æ›´", "info")

@bot.tree.command(name="set_user_period", description="å€‹äººå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰")
@app_commands.describe(
    user="å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼", 
    role="ãƒ­ãƒ¼ãƒ«å", 
    days="æ—¥", 
    hours="æ™‚é–“", 
    minutes="åˆ†", 
    seconds="ç§’"
)
@app_commands.choices(role=[app_commands.Choice(name=r, value=r) for r in ROLES_TO_AUTO_REMOVE])
@admin_required
async def set_user_period(
    interaction: discord.Interaction, 
    user: discord.Member, 
    role: str, 
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0
):
    total_seconds = parse_duration(days, hours, minutes, seconds)
    guild_id, user_id = str(interaction.guild.id), str(user.id)
    current_seconds = bot.data.get_remove_seconds(guild_id, user_id, role)
    default_seconds = bot.data.settings["remove_seconds"].get(role, DEFAULT_REMOVE_SECONDS[role])
    
    if total_seconds == 0:
        removed = bot.data.remove_user_setting(guild_id, user_id, role)
        title = "âœ… å€‹äººè¨­å®šå‰Šé™¤å®Œäº†" if removed else "â„¹ï¸ å€‹äººè¨­å®šãªã—"
        change = f"{format_duration(current_seconds)} â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ({format_duration(default_seconds)})" if removed else "å¤‰æ›´ãªã—"
    else:
        bot.data.set_user_remove_seconds(guild_id, user_id, role, total_seconds)
        title = "âœ… å€‹äººå‰Šé™¤æœŸé–“è¨­å®šå®Œäº†"
        change = f"{format_duration(current_seconds)} â†’ {format_duration(total_seconds)}"
    
    await bot.data.save_all()
    embed = await create_embed(title, 0x00ff00,
                              ãƒ¦ãƒ¼ã‚¶ãƒ¼=user.display_name, ãƒ­ãƒ¼ãƒ«=role, å¤‰æ›´=change)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="show_user_period", description="å€‹äººå‰Šé™¤æœŸé–“è¡¨ç¤º")
@app_commands.describe(user="å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆçœç•¥æ™‚ã¯è‡ªåˆ†ï¼‰")
async def show_user_period(interaction: discord.Interaction, user: discord.Member = None):
    if user is None:
        user = interaction.user
    
    guild_id, user_id = str(interaction.guild.id), str(user.id)
    embed = discord.Embed(title=f"ğŸ—‘ï¸ {user.display_name} ã®å‰Šé™¤æœŸé–“è¨­å®š", color=0x0099ff)
    
    for role_name in ROLES_TO_AUTO_REMOVE:
        personal_seconds = None
        default_seconds = bot.data.settings["remove_seconds"].get(role_name, DEFAULT_REMOVE_SECONDS[role_name])
        
        if (bot.data.settings.get("user_remove_seconds", {}).get(guild_id, {})
            .get(user_id, {}).get(role_name)):
            personal_seconds = bot.data.settings["user_remove_seconds"][guild_id][user_id][role_name]
        
        value = (
            f"**{format_duration(personal_seconds)}** (å€‹äººè¨­å®š)\nãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: {format_duration(default_seconds)}"
            if personal_seconds else f"{format_duration(default_seconds)} (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)"
        )
        embed.add_field(name=role_name, value=value, inline=True)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="sync_check", description="æ‰‹å‹•åŒæœŸãƒ»ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œï¼ˆç®¡ç†è€…é™å®šï¼‰")
@admin_required
async def sync_check(interaction: discord.Interaction):
    await interaction.response.defer(thinking=True)
    
    await sync_data_with_reality(interaction.guild)
    removed = await process_role_removal(interaction.guild)
    await bot.data.save_all()
    
    await interaction.followup.send(f"âœ… æ‰‹å‹•åŒæœŸå®Œäº†\nå‰Šé™¤ã•ã‚ŒãŸãƒ­ãƒ¼ãƒ«: {removed}å€‹")
    await log_message(interaction.guild, f"{interaction.user.display_name} ãŒæ‰‹å‹•åŒæœŸå®Ÿè¡Œ: {removed}å€‹å‰Šé™¤", "info")

@bot.tree.command(name="help", description="ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§è¡¨ç¤º")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(title="ğŸ¤– ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§", color=0x0099ff)
    commands_info = {
        "/giveall": "å…¨å“¡ã«ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆç®¡ç†è€…é™å®šï¼‰",
        "/test_add": "è‡ªåˆ†ã«ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰",
        "/status": "BotçŠ¶æ…‹è¡¨ç¤º",
        "/set_remove_period": "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰",
        "/set_user_period": "å€‹äººå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰",
        "/show_user_period": "å€‹äººå‰Šé™¤æœŸé–“è¡¨ç¤º",
        "/sync_check": "æ‰‹å‹•åŒæœŸãƒ»ãƒã‚§ãƒƒã‚¯ï¼ˆç®¡ç†è€…é™å®šï¼‰"
    }
    
    for cmd, desc in commands_info.items():
        embed.add_field(name=cmd, value=desc, inline=False)
    
    embed.add_field(name="âš ï¸ é‡è¦äº‹é …", 
                   value=f"â€¢ è‡ªå‹•å‰Šé™¤å¯¾è±¡: {', '.join(ROLES_TO_AUTO_REMOVE)}\nâ€¢ ä¸å®šæœŸèµ·å‹•å¯¾å¿œ\nâ€¢ å€‹äººåˆ¥å‰Šé™¤æœŸé–“è¨­å®šå¯èƒ½", 
                   inline=False)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message("âŒ å¿…è¦ãªæ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚", ephemeral=True)
    elif isinstance(error, app_commands.CommandOnCooldown):
        await interaction.response.send_message(f"âŒ ã‚³ãƒãƒ³ãƒ‰ã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã§ã™ã€‚{error.retry_after:.1f}ç§’å¾Œã«å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚", ephemeral=True)
    else:
        logger.error(f"Application command error: {error}", exc_info=True)
        if not interaction.response.is_done():
            await interaction.response.send_message("âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", ephemeral=True)

TOKEN = os.environ.get("BOT_TOKEN")

if __name__ == "__main__":
    if not TOKEN:
        logger.error("BOT_TOKEN environment variable is not set")
        logger.error("ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¨­å®šã—ã¦ãã ã•ã„:")
        logger.error("  Windows: set BOT_TOKEN=ã‚ãªãŸã®ãƒˆãƒ¼ã‚¯ãƒ³")
        logger.error("  Mac/Linux: export BOT_TOKEN=ã‚ãªãŸã®ãƒˆãƒ¼ã‚¯ãƒ³")
        exit(1)
    
    try:
        logger.info("Starting bot...")
        bot.run(TOKEN)
    except discord.LoginFailure:
        logger.error("Invalid bot token")
        exit(1)
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        exit(1)
