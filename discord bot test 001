# -*- coding: utf-8 -*-
import discord
from discord.ext import tasks
from discord import app_commands
import json
import os
from datetime import datetime
import asyncio
import shutil
import logging

# ====================== ãƒ­ã‚®ãƒ³ã‚°è¨­å®š ======================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ====================== è¨­å®š ======================
DEBUG = False

if DEBUG:
    CHECK_INTERVAL = 5        # ãƒã‚§ãƒƒã‚¯é–“éš”ï¼ˆç§’ï¼‰
    SYNC_INTERVAL = 10         # ãƒ‡ãƒ¼ã‚¿åŒæœŸé–“éš”ï¼ˆç§’ï¼‰- ãƒ†ã‚¹ãƒˆç”¨
    REMOVE_AFTER = 15          # å‰Šé™¤ã¾ã§ã®æœŸé–“ï¼ˆç§’ï¼‰- ãƒ†ã‚¹ãƒˆç”¨
    BATCH_SIZE = 20            # ãƒãƒƒãƒã‚µã‚¤ã‚ºã‚’å°ã•ãï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–ï¼‰
    API_DELAY = 0.5           # APIå‘¼ã³å‡ºã—é–“ã®å¾…æ©Ÿæ™‚é–“
else:
    CHECK_INTERVAL = 60*10     # 10åˆ†é–“éš”ã§ãƒ­ãƒ¼ãƒ«å‰Šé™¤ãƒã‚§ãƒƒã‚¯
    SYNC_INTERVAL = 60*60      # 1æ™‚é–“é–“éš”ã§ãƒ‡ãƒ¼ã‚¿åŒæœŸ
    REMOVE_AFTER = 60*60*24*30*3  # 3ã‹æœˆï¼ˆç§’ï¼‰
    BATCH_SIZE = 50
    API_DELAY = 0.2

ROLES_TO_AUTO_REMOVE = ["æ³¨æ„", "è­¦å‘Š"]
DATA_FILE = "roles_data.json"
BACKUP_DIR = "backup"
LOG_CHANNEL_NAME = "bot-logs"
LOG_CHANNEL_ID = None

# ====================== Bot åˆæœŸåŒ– ======================
intents = discord.Intents.default()
intents.members = True
intents.message_content = True

class MyBot(discord.Client):
    def __init__(self):
        super().__init__(intents=intents)
        self.tree = app_commands.CommandTree(self)
        self._data_lock = asyncio.Lock()  # ãƒ‡ãƒ¼ã‚¿ã®åŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹é˜²æ­¢

    async def setup_hook(self):
        logger.info("Setting up bot...")
        try:
            synced = await self.tree.sync()
            logger.info(f"Synced {len(synced)} commands globally")
        except Exception as e:
            logger.error(f"Failed to sync globally: {e}")

        for guild in self.guilds:
            try:
                self.tree.copy_global_to(guild=guild)
                synced = await self.tree.sync(guild=guild)
                logger.info(f"Synced {len(synced)} commands to guild: {guild.name} (ID: {guild.id})")
            except Exception as e:
                logger.error(f"Failed to sync commands for guild {guild.name}: {e}")

bot = MyBot()

# ====================== ãƒ‡ãƒ¼ã‚¿æ“ä½œï¼ˆæ”¹å–„ç‰ˆï¼‰ ======================

def ensure_backup_dir():
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å­˜åœ¨ç¢ºä¿"""
    try:
        os.makedirs(BACKUP_DIR, exist_ok=True)
    except Exception as e:
        logger.error(f"Failed to create backup directory: {e}")

def backup_file():
    """ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—"""
    ensure_backup_dir()
    if not os.path.exists(DATA_FILE):
        return
    
    timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    backup_path = os.path.join(BACKUP_DIR, f"roles_data_{timestamp}.json")
    
    try:
        shutil.copy2(DATA_FILE, backup_path)
        logger.info(f"Backup created: {backup_path}")
        
        # å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã®å‰Šé™¤ï¼ˆ10å€‹ä»¥ä¸Šä¿æŒã—ãªã„ï¼‰
        cleanup_old_backups()
    except Exception as e:
        logger.error(f"Backup failed: {e}")

def cleanup_old_backups():
    """å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤"""
    try:
        if not os.path.exists(BACKUP_DIR):
            return
            
        backups = [f for f in os.listdir(BACKUP_DIR) if f.startswith("roles_data_")]
        backups.sort(reverse=True)
        
        # 10å€‹ä»¥ä¸Šã‚ã‚‹å ´åˆã€å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
        for old_backup in backups[10:]:
            old_path = os.path.join(BACKUP_DIR, old_backup)
            os.remove(old_path)
            logger.info(f"Removed old backup: {old_backup}")
    except Exception as e:
        logger.error(f"Failed to cleanup old backups: {e}")

def load_data():
    """ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ï¼‰"""
    if not os.path.exists(DATA_FILE):
        logger.info("Data file not found, initializing empty data")
        return {}
    
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            logger.info("Data loaded successfully")
            return data
    except (json.JSONDecodeError, PermissionError) as e:
        logger.error(f"Error loading {DATA_FILE}: {e}, attempting backup restore")
        return restore_from_backup()

def restore_from_backup():
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ã®å¾©å…ƒ"""
    if not os.path.exists(BACKUP_DIR):
        logger.warning("No backup directory found")
        return {}
        
    backups = [f for f in os.listdir(BACKUP_DIR) if f.startswith("roles_data_")]
    backups.sort(reverse=True)
    
    for backup in backups:
        backup_path = os.path.join(BACKUP_DIR, backup)
        try:
            with open(backup_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                logger.info(f"Restored from backup: {backup}")
                return data
        except Exception as e:
            logger.error(f"Failed to restore from {backup}: {e}")
            continue
    
    logger.warning("No valid backup found, initializing empty data")
    return {}

async def save_data(data):
    """ãƒ‡ãƒ¼ã‚¿ä¿å­˜ï¼ˆéåŒæœŸãƒ­ãƒƒã‚¯ä»˜ãï¼‰"""
    async with bot._data_lock:
        try:
            backup_file()
            # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚“ã§ã‹ã‚‰ç§»å‹•ï¼ˆåŸå­æ€§ç¢ºä¿ï¼‰
            temp_file = f"{DATA_FILE}.tmp"
            with open(temp_file, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            # å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç½®æ›
            if os.path.exists(DATA_FILE):
                os.replace(temp_file, DATA_FILE)
            else:
                os.rename(temp_file, DATA_FILE)
                
            logger.debug("Data saved successfully")
        except Exception as e:
            logger.error(f"Failed to save {DATA_FILE}: {e}")
            # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã¯å‰Šé™¤
            temp_file = f"{DATA_FILE}.tmp"
            if os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                except Exception:
                    pass

# ãƒ‡ãƒ¼ã‚¿åˆæœŸåŒ–
role_data = load_data()

# ====================== ãƒ­ã‚°é€ä¿¡ï¼ˆæ”¹å–„ç‰ˆï¼‰ ======================
async def log_message(guild, message, level="info"):
    """ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ï¼ˆãƒ¬ãƒ™ãƒ«æŒ‡å®šå¯èƒ½ï¼‰"""
    try:
        # ãƒãƒ£ãƒ³ãƒãƒ«å–å¾—
        channel = None
        if LOG_CHANNEL_ID:
            channel = guild.get_channel(LOG_CHANNEL_ID)
        
        if not channel and LOG_CHANNEL_NAME:
            channel = discord.utils.get(guild.text_channels, name=LOG_CHANNEL_NAME)
        
        # Discord ã¸ã®ãƒ­ã‚°é€ä¿¡
        if channel:
            # ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦çµµæ–‡å­—ã‚’ä»˜ã‘ã‚‹
            emoji_map = {
                "info": "â„¹ï¸",
                "success": "âœ…",
                "warning": "âš ï¸", 
                "error": "âŒ"
            }
            emoji = emoji_map.get(level, "ğŸ“")
            
            # é•·ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯åˆ†å‰²
            if len(message) > 1800:
                chunks = [message[i:i+1800] for i in range(0, len(message), 1800)]
                for i, chunk in enumerate(chunks):
                    if i == 0:
                        await channel.send(f"{emoji} {chunk}")
                    else:
                        await channel.send(f"ğŸ“„ (ç¶šã) {chunk}")
            else:
                await channel.send(f"{emoji} {message}")
        else:
            logger.warning(f"Log channel not found in guild {guild.name}")
            
    except discord.HTTPException as e:
        if e.status == 429:  # Rate limit
            logger.warning(f"Rate limited when logging to Discord: {e}")
        else:
            logger.error(f"Discord error when logging: {e}")
    except Exception as e:
        logger.error(f"Failed to log message to Discord: {e}")
    
    # ã‚³ãƒ³ã‚½ãƒ¼ãƒ«/ãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ã‚°
    log_text = f"[{guild.name}] {message}"
    if level == "error":
        logger.error(log_text)
    elif level == "warning":
        logger.warning(log_text)
    else:
        logger.info(log_text)

# ====================== ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ãƒ»ä¿®æ­£ï¼ˆå®šæœŸåŒæœŸå¯¾å¿œç‰ˆï¼‰ ======================
async def sync_data_with_reality(guild, is_periodic=False):
    """ã‚µãƒ¼ãƒãƒ¼ã®å®Ÿéš›ã®çŠ¶æ…‹ã¨ãƒ‡ãƒ¼ã‚¿ã‚’åŒæœŸï¼ˆä¸å®šæœŸèµ·å‹•å¯¾å¿œï¼‰"""
    try:
        now = datetime.utcnow().timestamp()
        guild_id = str(guild.id)
        
        if guild_id not in role_data:
            role_data[guild_id] = {}
        
        # ç¾åœ¨ã®ãƒ­ãƒ¼ãƒ«ä¿æŒè€…ã‚’å–å¾—
        current_role_holders = {}
        for member in guild.members:
            if member.bot:
                continue
            
            user_id = str(member.id)
            for role in member.roles:
                if role.name in ROLES_TO_AUTO_REMOVE:
                    if user_id not in current_role_holders:
                        current_role_holders[user_id] = []
                    current_role_holders[user_id].append(role.name)
        
        changes_made = False
        removed_count = 0
        added_count = 0
        
        # ãƒ‡ãƒ¼ã‚¿ã«è¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹ãŒå®Ÿéš›ã«ã¯ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ãªã„äººã‚’å‰Šé™¤
        users_to_remove = []
        for user_id, user_roles in list(role_data[guild_id].items()):
            if user_id not in current_role_holders:
                # ãƒ­ãƒ¼ãƒ«ã‚’å…¨ãæŒã£ã¦ã„ãªã„å ´åˆ
                users_to_remove.append(user_id)
                removed_count += len(user_roles)
            else:
                # ä¸€éƒ¨ã®ãƒ­ãƒ¼ãƒ«ãŒãªã„å ´åˆ
                roles_to_remove = []
                for role_name in list(user_roles.keys()):
                    if role_name not in current_role_holders[user_id]:
                        roles_to_remove.append(role_name)
                        removed_count += 1
                
                for role_name in roles_to_remove:
                    del role_data[guild_id][user_id][role_name]
                    changes_made = True
                
                # ç©ºã«ãªã£ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
                if not role_data[guild_id][user_id]:
                    users_to_remove.append(user_id)
        
        for user_id in users_to_remove:
            del role_data[guild_id][user_id]
            changes_made = True
        
        # å®Ÿéš›ã«ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã‚‹ãŒãƒ‡ãƒ¼ã‚¿ã«è¨˜éŒ²ã•ã‚Œã¦ã„ãªã„äººã‚’è¿½åŠ 
        for user_id, roles in current_role_holders.items():
            if user_id not in role_data[guild_id]:
                role_data[guild_id][user_id] = {}
            
            for role_name in roles:
                if role_name not in role_data[guild_id][user_id]:
                    # ç¾åœ¨æ™‚åˆ»ã‚’ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¨ã—ã¦è¨­å®š
                    role_data[guild_id][user_id][role_name] = now
                    changes_made = True
                    added_count += 1
        
        if changes_made:
            await save_data(role_data)
            sync_type = "å®šæœŸåŒæœŸ" if is_periodic else "èµ·å‹•æ™‚åŒæœŸ"
            sync_msg = f"{sync_type}å®Œäº†: å‰Šé™¤ {removed_count}ä»¶, è¿½åŠ  {added_count}ä»¶"
            logger.info(f"[{guild.name}] {sync_msg}")
            
            # å®šæœŸåŒæœŸã®å ´åˆã¯å¤‰æ›´ãŒã‚ã£ãŸæ™‚ã®ã¿Discordãƒ­ã‚°ã«é€ä¿¡
            if is_periodic and (removed_count > 0 or added_count > 0):
                await log_message(guild, sync_msg, "info")
            elif not is_periodic:
                await log_message(guild, sync_msg, "info")
        else:
            sync_type = "å®šæœŸåŒæœŸ" if is_periodic else "èµ·å‹•æ™‚åŒæœŸ"
            logger.info(f"[{guild.name}] {sync_type}: å¤‰æ›´ãªã—")
        
        return {"removed": removed_count, "added": added_count}
        
    except Exception as e:
        logger.error(f"Error syncing data for guild {guild.name}: {e}")
        await log_message(guild, f"ãƒ‡ãƒ¼ã‚¿åŒæœŸã‚¨ãƒ©ãƒ¼: {e}", "error")
        return {"removed": 0, "added": 0}

# ====================== è‡ªå‹•å‰Šé™¤å‡¦ç†ï¼ˆä¸å®šæœŸèµ·å‹•å¯¾å¿œç‰ˆï¼‰ ======================
async def process_member_roles(guild, user_id, member_roles, now):
    """ãƒ¡ãƒ³ãƒãƒ¼ã®å½¹è·å‡¦ç†ï¼ˆä¸å®šæœŸèµ·å‹•å¯¾å¿œï¼‰"""
    try:
        member = guild.get_member(int(user_id))
        if not member:
            # ãƒ¡ãƒ³ãƒãƒ¼ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å‰Šé™¤
            guild_id = str(guild.id)
            if guild_id in role_data and user_id in role_data[guild_id]:
                del role_data[guild_id][user_id]
                logger.info(f"Removed data for user {user_id} (not found in guild)")
            return 0

        guild_id = str(guild.id)
        roles_to_remove = []
        
        for role_name, timestamp in list(member_roles.items()):
            if role_name not in ROLES_TO_AUTO_REMOVE:
                continue
                
            role = discord.utils.get(guild.roles, name=role_name)
            if not role:
                # ãƒ­ãƒ¼ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å‰Šé™¤
                if guild_id in role_data and user_id in role_data[guild_id]:
                    role_data[guild_id][user_id].pop(role_name, None)
                    logger.info(f"Removed data for non-existent role {role_name}")
                continue
            
            # ãƒ¡ãƒ³ãƒãƒ¼ãŒå®Ÿéš›ã«ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if role not in member.roles:
                # ãƒ‡ãƒ¼ã‚¿ã«ã¯ã‚ã‚‹ãŒå®Ÿéš›ã«ã¯ãƒ­ãƒ¼ãƒ«ãŒãªã„å ´åˆï¼ˆæ‰‹å‹•å‰Šé™¤ã•ã‚ŒãŸï¼‰
                if guild_id in role_data and user_id in role_data[guild_id]:
                    role_data[guild_id][user_id].pop(role_name, None)
                    logger.info(f"Removed data for manually removed role {role_name} from {member.name}")
                continue
            
            # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒNoneã®å ´åˆã¯ç¾åœ¨æ™‚åˆ»ã‚’è¨­å®š
            if timestamp is None:
                role_data[guild_id][user_id][role_name] = now
                logger.info(f"Set timestamp for {member.name}'s {role_name} role")
                continue
            
            # å‰Šé™¤æœŸé–“ã‚’éãã¦ã„ã‚‹å ´åˆ
            if now - timestamp >= REMOVE_AFTER:
                roles_to_remove.append((role, role_name))
        
        # ãƒ­ãƒ¼ãƒ«å‰Šé™¤ã®å®Ÿè¡Œ
        removed_count = 0
        for role, role_name in roles_to_remove:
            try:
                await member.remove_roles(role, reason=f"è‡ªå‹•å‰Šé™¤ï¼ˆæœŸé–“æº€äº†: {REMOVE_AFTER//86400}æ—¥çµŒéï¼‰")
                
                # å‰Šé™¤æ—¥æ™‚ã®è¨ˆç®—
                assigned_time = datetime.fromtimestamp(member_roles[role_name])
                days_passed = (now - member_roles[role_name]) // 86400
                
                log_msg = f"{member.display_name} ã‹ã‚‰ '{role_name}' ã‚’è‡ªå‹•å‰Šé™¤ (ä»˜ä¸æ—¥: {assigned_time.strftime('%Y/%m/%d %H:%M')}, çµŒéæ—¥æ•°: {int(days_passed)}æ—¥)"
                await log_message(guild, log_msg, "success")
                
                # ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å‰Šé™¤
                if guild_id in role_data and user_id in role_data[guild_id]:
                    role_data[guild_id][user_id].pop(role_name, None)
                
                removed_count += 1
                    
            except discord.Forbidden:
                await log_message(guild, f"{member.display_name} ã‹ã‚‰ {role_name} ã®å‰Šé™¤ã«å¤±æ•—ï¼ˆæ¨©é™ä¸è¶³ï¼‰", "warning")
            except discord.HTTPException as e:
                if e.status == 429:  # Rate limit
                    logger.warning(f"Rate limited removing role from {member}: {e}")
                    await asyncio.sleep(2)
                else:
                    await log_message(guild, f"{member.display_name} ã‹ã‚‰ {role_name} ã®å‰Šé™¤ã«å¤±æ•—: HTTP {e.status}", "error")
            except Exception as e:
                await log_message(guild, f"{member.display_name} ã‹ã‚‰ {role_name} ã®å‰Šé™¤ã§ã‚¨ãƒ©ãƒ¼: {e}", "error")

        # ç©ºã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
        if (guild_id in role_data and user_id in role_data[guild_id] 
            and not role_data[guild_id][user_id]):
            del role_data[guild_id][user_id]
        
        return removed_count
            
    except Exception as e:
        logger.error(f"Error processing member {user_id} in guild {guild.id}: {e}")
        return 0

@tasks.loop(seconds=CHECK_INTERVAL)
async def check_roles():
    """å®šæœŸçš„ãªå½¹è·ãƒã‚§ãƒƒã‚¯ï¼ˆä¸å®šæœŸèµ·å‹•å¯¾å¿œç‰ˆï¼‰"""
    try:
        logger.info("Starting role check cycle")
        now = datetime.utcnow().timestamp()
        total_removed = 0
        
        for guild in bot.guilds:
            guild_id = str(guild.id)
            if guild_id not in role_data or not role_data[guild_id]:
                continue
                
            user_ids = list(role_data[guild_id].keys())
            logger.info(f"Checking {len(user_ids)} users in guild {guild.name}")
            
            guild_removed = 0
            
            # ãƒãƒƒãƒå‡¦ç†
            for i in range(0, len(user_ids), BATCH_SIZE):
                batch = user_ids[i:i+BATCH_SIZE]
                
                # é€æ¬¡å‡¦ç†ï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–ï¼‰
                for uid in batch:
                    if uid in role_data[guild_id]:  # ãƒ‡ãƒ¼ã‚¿ãŒå‰Šé™¤ã•ã‚Œã¦ã„ãªã„ã‹ç¢ºèª
                        removed = await process_member_roles(guild, uid, role_data[guild_id][uid].copy(), now)
                        guild_removed += removed
                        await asyncio.sleep(0.1)  # å€‹åˆ¥ã®APIå‘¼ã³å‡ºã—é–“éš”
                
                # ãƒãƒƒãƒé–“ã®å¾…æ©Ÿæ™‚é–“
                if i + BATCH_SIZE < len(user_ids):
                    await asyncio.sleep(API_DELAY)
            
            total_removed += guild_removed
            if guild_removed > 0:
                logger.info(f"[{guild.name}] Removed {guild_removed} roles")
        
        # ãƒ‡ãƒ¼ã‚¿ä¿å­˜
        await save_data(role_data)
        
        if total_removed > 0:
            logger.info(f"Role check cycle completed - Total removed: {total_removed}")
        else:
            logger.info("Role check cycle completed - No roles removed")
        
    except Exception as e:
        logger.error(f"Error in check_roles task: {e}")

@check_roles.before_loop
async def before_check_roles():
    """ã‚¿ã‚¹ã‚¯é–‹å§‹å‰ã«Botã®æº–å‚™å®Œäº†ã‚’å¾…æ©Ÿ"""
    await bot.wait_until_ready()

# ====================== å®šæœŸåŒæœŸã‚¿ã‚¹ã‚¯ ======================
@tasks.loop(seconds=SYNC_INTERVAL)
async def sync_data_periodically():
    """å®šæœŸçš„ãªãƒ‡ãƒ¼ã‚¿åŒæœŸï¼ˆ1æ™‚é–“é–“éš”ï¼‰"""
    try:
        logger.info("Starting periodic data sync")
        total_changes = {"removed": 0, "added": 0}
        
        for guild in bot.guilds:
            try:
                result = await sync_data_with_reality(guild, is_periodic=True)
                total_changes["removed"] += result["removed"]
                total_changes["added"] += result["added"]
                
                # ã‚µãƒ¼ãƒãƒ¼é–“ã§å°‘ã—å¾…æ©Ÿ
                await asyncio.sleep(1)
                
            except Exception as e:
                logger.error(f"Error in periodic sync for guild {guild.name}: {e}")
        
        # ãƒ‡ãƒ¼ã‚¿ä¿å­˜
        await save_data(role_data)
        
        if total_changes["removed"] > 0 or total_changes["added"] > 0:
            logger.info(f"Periodic sync completed - Removed: {total_changes['removed']}, Added: {total_changes['added']}")
        else:
            logger.info("Periodic sync completed - No changes")
        
    except Exception as e:
        logger.error(f"Error in periodic sync task: {e}")

@sync_data_periodically.before_loop
async def before_sync_data():
    """åŒæœŸã‚¿ã‚¹ã‚¯é–‹å§‹å‰ã«Botã®æº–å‚™å®Œäº†ã‚’å¾…æ©Ÿ"""
    await bot.wait_until_ready()

# ====================== ãƒ­ãƒ¼ãƒ«ç®¡ç†é–¢æ•°ï¼ˆæ”¹å–„ç‰ˆï¼‰ ======================
async def add_role_with_timestamp(member, role, silent=False, reason=None):
    """ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
    try:
        guild_id = str(member.guild.id)
        user_id = str(member.id)
        
        # ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®åˆæœŸåŒ–
        if guild_id not in role_data:
            role_data[guild_id] = {}
        if user_id not in role_data[guild_id]:
            role_data[guild_id][user_id] = {}
        
        # æ—¢ã«ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        if role in member.roles:
            return True
            
        # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®è¨˜éŒ²ï¼ˆæ—¢å­˜ã§ãªã„å ´åˆã®ã¿ï¼‰
        if role.name not in role_data[guild_id][user_id]:
            role_data[guild_id][user_id][role.name] = datetime.utcnow().timestamp()
        
        # ãƒ­ãƒ¼ãƒ«ä»˜ä¸
        audit_reason = reason or ("è‡ªå‹•ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆé™éŸ³ï¼‰" if silent else "è‡ªå‹•ãƒ­ãƒ¼ãƒ«ä»˜ä¸")
        await member.add_roles(role, reason=audit_reason)
        
        await save_data(role_data)
        return True
        
    except discord.Forbidden:
        logger.error(f"Failed to add role {role.name} to {member}: Forbidden")
        return False
    except discord.HTTPException as e:
        if e.status == 429:  # Rate limit
            logger.warning(f"Rate limited adding role to {member}: {e}")
            await asyncio.sleep(2)
        else:
            logger.error(f"HTTP error adding role {role.name} to {member}: {e}")
        return False
    except Exception as e:
        logger.error(f"Unexpected error adding role {role.name} to {member}: {e}")
        return False

# ====================== Bot ã‚¤ãƒ™ãƒ³ãƒˆ ======================
@bot.event
async def on_ready():
    logger.info(f"Logged in as {bot.user} (ID: {bot.user.id})")
    logger.info(f"Connected to {len(bot.guilds)} guilds")
    
    try:
        startup_time = datetime.utcnow()
        
        for guild in bot.guilds:
            logger.info(f"Guild: {guild.name} (ID: {guild.id})")
            startup_msg = f"Botèµ·å‹•å®Œäº† ({startup_time.strftime('%Y/%m/%d %H:%M:%S')} UTC)"
            await log_message(guild, startup_msg, "success")
            
            # ãƒ‡ãƒ¼ã‚¿åŒæœŸï¼ˆä¸å®šæœŸèµ·å‹•å¯¾å¿œã®æ ¸å¿ƒéƒ¨åˆ†ï¼‰
            await sync_data_with_reality(guild, is_periodic=False)
        
        await save_data(role_data)
        
        # å®šæœŸã‚¿ã‚¹ã‚¯é–‹å§‹
        if not check_roles.is_running():
            check_roles.start()
            logger.info("Role check task started")
        
        if not sync_data_periodically.is_running():
            sync_data_periodically.start()
            logger.info("Periodic data sync task started")
            
        logger.info("Bot is ready and data synchronized!")
        
        # èµ·å‹•æ™‚ã«æœŸé–“æº€äº†ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ
        logger.info("Performing startup role check...")
        await check_roles.coro()
        
    except Exception as e:
        logger.error(f"Error in on_ready: {e}")

@bot.event
async def on_error(event, *args, **kwargs):
    logger.error(f"Discord event error in {event}: {args}", exc_info=True)

# ====================== ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ ======================
@bot.tree.command(name="giveall", description="å…¨å“¡ã«æŒ‡å®šã—ãŸãƒ­ãƒ¼ãƒ«ã‚’ä»˜ä¸")
@app_commands.describe(
    role="ä»˜ä¸ã™ã‚‹ãƒ­ãƒ¼ãƒ«",
    silent="é™éŸ³ãƒ¢ãƒ¼ãƒ‰ï¼ˆç›£æŸ»ãƒ­ã‚°ã®ã¿å¤‰æ›´ã€é€šçŸ¥åˆ¶å¾¡ã¯é™å®šçš„ï¼‰"
)
async def giveall(interaction: discord.Interaction, role: discord.Role, silent: bool = False):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("âŒ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚", ephemeral=True)
        return

    # Botè‡ªèº«ã®æ¨©é™ãƒã‚§ãƒƒã‚¯
    if not interaction.guild.me.guild_permissions.manage_roles:
        await interaction.response.send_message("âŒ Botã«ãƒ­ãƒ¼ãƒ«ç®¡ç†æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚", ephemeral=True)
        return
    
    # ãƒ­ãƒ¼ãƒ«ã®éšå±¤ãƒã‚§ãƒƒã‚¯
    if role >= interaction.guild.me.top_role:
        await interaction.response.send_message("âŒ ãã®ãƒ­ãƒ¼ãƒ«ã¯Botã®æ¨©é™ã‚ˆã‚Šä¸Šä½ã®ãŸã‚ä»˜ä¸ã§ãã¾ã›ã‚“ã€‚", ephemeral=True)
        return

    await interaction.response.defer(thinking=True)
    
    try:
        members = [m for m in interaction.guild.members if not m.bot and role not in m.roles]
        total_members = len(members)
        
        if total_members == 0:
            await interaction.followup.send("âœ… å…¨å“¡ãŒæ—¢ã«è©²å½“ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã¾ã™ã€‚")
            return
        
        progress_msg = await interaction.followup.send(
            f"ğŸ”„ {role.name} ã‚’ {total_members} äººã«ä»˜ä¸ä¸­... (0/{total_members})"
        )
        
        success, failed = 0, 0
        failed_members = []
        
        # ãƒãƒƒãƒå‡¦ç†
        for i in range(0, len(members), BATCH_SIZE):
            batch = members[i:i+BATCH_SIZE]
            
            for member in batch:
                try:
                    result = await add_role_with_timestamp(
                        member, role, silent, 
                        f"ä¸€æ‹¬ä»˜ä¸ by {interaction.user.display_name}"
                    )
                    if result:
                        success += 1
                    else:
                        failed += 1
                        failed_members.append(member.display_name)
                except Exception as e:
                    logger.error(f"Error in giveall for {member}: {e}")
                    failed += 1
                    failed_members.append(member.display_name)
                    
                # å€‹åˆ¥ã®å¾…æ©Ÿæ™‚é–“
                await asyncio.sleep(0.1)
            
            # é€²è¡ŒçŠ¶æ³æ›´æ–°
            processed = success + failed
            if processed % (BATCH_SIZE * 2) == 0 or processed == total_members:
                try:
                    await progress_msg.edit(
                        content=f"ğŸ”„ {role.name} ã‚’ä»˜ä¸ä¸­... ({processed}/{total_members})"
                    )
                except discord.NotFound:
                    pass  # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆ
            
            # ãƒãƒƒãƒé–“ã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–
            if i + BATCH_SIZE < len(members):
                await asyncio.sleep(API_DELAY)
        
        # çµæœå ±å‘Š
        result_msg = f"âœ… {role.name} ã®ä¸€æ‹¬ä»˜ä¸å®Œäº†ï¼\n"
        result_msg += f"æˆåŠŸ: {success}äºº / å¤±æ•—: {failed}äºº"
        
        if silent:
            result_msg += "\nğŸ”‡ é™éŸ³ãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œ"
        
        if role.name in ROLES_TO_AUTO_REMOVE:
            days = REMOVE_AFTER // 86400
            result_msg += f"\nâ° {days}æ—¥å¾Œã«è‡ªå‹•å‰Šé™¤ã•ã‚Œã¾ã™"
        
        if failed > 0:
            if failed <= 5:
                result_msg += f"\nâŒ å¤±æ•—: {', '.join(failed_members)}"
            else:
                result_msg += f"\nâŒ å¤±æ•—: {', '.join(failed_members[:3])} ä»–{failed-3}äºº"
        
        await progress_msg.edit(content=result_msg)
        
        # ãƒ­ã‚°è¨˜éŒ²
        await log_message(
            interaction.guild,
            f"ç®¡ç†è€… {interaction.user.display_name} ãŒ {role.name} ã‚’ä¸€æ‹¬ä»˜ä¸: æˆåŠŸ{success}äºº, å¤±æ•—{failed}äºº",
            "success" if failed == 0 else "warning"
        )
        
    except Exception as e:
        logger.error(f"Error in giveall command: {e}")
        try:
            await interaction.followup.send(f"âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")
        except discord.NotFound:
            pass

@bot.tree.command(name="test_add", description="è‡ªåˆ†ã«ãƒ­ãƒ¼ãƒ«ã‚’ä»˜ä¸ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰")
@app_commands.describe(role="ä»˜ä¸ã™ã‚‹ãƒ­ãƒ¼ãƒ«", silent="é™éŸ³ãƒ¢ãƒ¼ãƒ‰")
async def test_add(interaction: discord.Interaction, role: discord.Role, silent: bool = False):
    if role >= interaction.guild.me.top_role:
        await interaction.response.send_message("âŒ ãã®ãƒ­ãƒ¼ãƒ«ã¯ä»˜ä¸ã§ãã¾ã›ã‚“ï¼ˆæ¨©é™ä¸è¶³ï¼‰", ephemeral=True)
        return
    
    try:
        result = await add_role_with_timestamp(
            interaction.user, role, silent, 
            f"ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰ by {interaction.user.display_name}"
        )
        
        if result:
            msg = f"âœ… {role.name} ã‚’ä»˜ä¸ã—ã¾ã—ãŸ"
            if silent:
                msg += "ï¼ˆé™éŸ³ãƒ¢ãƒ¼ãƒ‰ï¼‰"
            if role.name in ROLES_TO_AUTO_REMOVE:
                days = REMOVE_AFTER // 86400
                msg += f"\nâ° {days}æ—¥å¾Œã«è‡ªå‹•å‰Šé™¤ã•ã‚Œã¾ã™"
            await interaction.response.send_message(msg)
            await log_message(interaction.guild, f"ãƒ†ã‚¹ãƒˆ: {interaction.user.display_name} ã« {role.name} ã‚’ä»˜ä¸", "info")
        else:
            await interaction.response.send_message("âŒ ãƒ­ãƒ¼ãƒ«ä»˜ä¸ã«å¤±æ•—ã—ã¾ã—ãŸ", ephemeral=True)
            
    except Exception as e:
        logger.error(f"Error in test_add: {e}")
        await interaction.response.send_message(f"âŒ ã‚¨ãƒ©ãƒ¼: {str(e)}", ephemeral=True)

@bot.tree.command(name="status", description="Botã®çŠ¶æ…‹ã‚’è¡¨ç¤º")
async def status_command(interaction: discord.Interaction):
    try:
        guild_id = str(interaction.guild.id)
        tracked_users = len(role_data.get(guild_id, {}))
        
        # ãƒ­ãƒ¼ãƒ«åˆ¥ã®çµ±è¨ˆ
        role_stats = {}
        expiring_soon = {"æ³¨æ„": 0, "è­¦å‘Š": 0}
        now = datetime.utcnow().timestamp()
        
        if guild_id in role_data:
            for user_data in role_data[guild_id].values():
                for role_name, timestamp in user_data.items():
                    role_stats[role_name] = role_stats.get(role_name, 0) + 1
                    
                    # æ®‹ã‚Šæ™‚é–“ãŒ1é€±é–“ä»¥å†…ã®å ´åˆã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                    if timestamp and role_name in expiring_soon:
                        time_remaining = REMOVE_AFTER - (now - timestamp)
                        if 0 < time_remaining <= 604800:  # 1é€±é–“ = 604800ç§’
                            expiring_soon[role_name] += 1
        
        embed = discord.Embed(title="Bot ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", color=0x00ff00)
        embed.add_field(name="è¿½è·¡ä¸­ãƒ¦ãƒ¼ã‚¶ãƒ¼", value=f"{tracked_users}äºº", inline=True)
        embed.add_field(name="ãƒ­ãƒ¼ãƒ«å‰Šé™¤ãƒã‚§ãƒƒã‚¯é–“éš”", value=f"{CHECK_INTERVAL//60}åˆ†", inline=True)
        embed.add_field(name="ãƒ‡ãƒ¼ã‚¿åŒæœŸé–“éš”", value=f"{SYNC_INTERVAL//60}åˆ†", inline=True)
        embed.add_field(name="è‡ªå‹•å‰Šé™¤æœŸé–“", value=f"{REMOVE_AFTER//86400}æ—¥", inline=True)
        
        if role_stats:
            stats_text = ""
            for role, count in role_stats.items():
                stats_text += f"{role}: {count}äºº"
                if role in expiring_soon and expiring_soon[role] > 0:
                    stats_text += f" (ã†ã¡1é€±é–“ä»¥å†…å‰Šé™¤: {expiring_soon[role]}äºº)"
                stats_text += "\n"
            embed.add_field(name="ãƒ­ãƒ¼ãƒ«åˆ¥çµ±è¨ˆ", value=stats_text.strip(), inline=False)
        
        # èµ·å‹•ãƒ¢ãƒ¼ãƒ‰èª¬æ˜
        embed.add_field(
            name="âš™ï¸ å‹•ä½œãƒ¢ãƒ¼ãƒ‰", 
            value="ä¸å®šæœŸèµ·å‹•å¯¾å¿œ\nâ€¢ èµ·å‹•æ™‚ã«ãƒ‡ãƒ¼ã‚¿åŒæœŸ\nâ€¢ å®šæœŸçš„ãƒ‡ãƒ¼ã‚¿åŒæœŸ\nâ€¢ å®šæœŸãƒã‚§ãƒƒã‚¯ã§è‡ªå‹•å‰Šé™¤", 
            inline=False
        )
        
        await interaction.response.send_message(embed=embed)
        
    except Exception as e:
        logger.error(f"Error in status command: {e}")
        await interaction.response.send_message("âŒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ", ephemeral=True)

@bot.tree.command(name="sync_check", description="ãƒ‡ãƒ¼ã‚¿åŒæœŸã¨ãƒ­ãƒ¼ãƒ«å‰Šé™¤ãƒã‚§ãƒƒã‚¯ã‚’æ‰‹å‹•å®Ÿè¡Œï¼ˆç®¡ç†è€…é™å®šï¼‰")
async def sync_check(interaction: discord.Interaction):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("âŒ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚", ephemeral=True)
        return
    
    await interaction.response.defer(thinking=True)
    
    try:
        # ãƒ‡ãƒ¼ã‚¿åŒæœŸ
        await sync_data_with_reality(interaction.guild, is_periodic=False)
        
        # ãƒ­ãƒ¼ãƒ«å‰Šé™¤ãƒã‚§ãƒƒã‚¯
        now = datetime.utcnow().timestamp()
        guild_id = str(interaction.guild.id)
        
        if guild_id not in role_data or not role_data[guild_id]:
            await interaction.followup.send("âœ… åŒæœŸå®Œäº†ã€‚è¿½è·¡ä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã„ã¾ã›ã‚“ã€‚")
            return
        
        user_ids = list(role_data[guild_id].keys())
        total_removed = 0
        
        for uid in user_ids:
            if uid in role_data[guild_id]:
                removed = await process_member_roles(interaction.guild, uid, role_data[guild_id][uid].copy(), now)
                total_removed += removed
                await asyncio.sleep(0.1)
        
        await save_data(role_data)
        
        result_msg = f"âœ… æ‰‹å‹•åŒæœŸãƒ»ãƒã‚§ãƒƒã‚¯å®Œäº†\n"
        result_msg += f"å‰Šé™¤ã•ã‚ŒãŸãƒ­ãƒ¼ãƒ«æ•°: {total_removed}"
        
        await interaction.followup.send(result_msg)
        await log_message(interaction.guild, f"ç®¡ç†è€… {interaction.user.display_name} ãŒæ‰‹å‹•åŒæœŸãƒ»ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ: {total_removed}å€‹å‰Šé™¤", "info")
        
    except Exception as e:
        logger.error(f"Error in sync_check command: {e}")
        await interaction.followup.send(f"âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")

@bot.tree.command(name="list_expiring", description="æœŸé™åˆ‡ã‚Œé–“è¿‘ã®ãƒ­ãƒ¼ãƒ«ã‚’è¡¨ç¤ºï¼ˆç®¡ç†è€…é™å®šï¼‰")
@app_commands.describe(days="ä½•æ—¥ä»¥å†…ã«æœŸé™åˆ‡ã‚Œã™ã‚‹ã‹ã‚’æŒ‡å®šï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 7æ—¥ï¼‰")
async def list_expiring(interaction: discord.Interaction, days: int = 7):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("âŒ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚", ephemeral=True)
        return
    
    if days < 1 or days > 90:
        await interaction.response.send_message("âŒ æ—¥æ•°ã¯1-90ã®ç¯„å›²ã§æŒ‡å®šã—ã¦ãã ã•ã„ã€‚", ephemeral=True)
        return
    
    try:
        guild_id = str(interaction.guild.id)
        now = datetime.utcnow().timestamp()
        expiring_users = []
        
        if guild_id in role_data:
            for user_id, user_roles in role_data[guild_id].items():
                member = interaction.guild.get_member(int(user_id))
                if not member:
                    continue
                
                for role_name, timestamp in user_roles.items():
                    if timestamp and role_name in ROLES_TO_AUTO_REMOVE:
                        time_remaining = REMOVE_AFTER - (now - timestamp)
                        days_remaining = time_remaining / 86400
                        
                        if 0 < days_remaining <= days:
                            assigned_date = datetime.fromtimestamp(timestamp)
                            expiring_users.append({
                                'member': member.display_name,
                                'role': role_name,
                                'days_remaining': int(days_remaining),
                                'assigned_date': assigned_date.strftime('%Y/%m/%d')
                            })
        
        if not expiring_users:
            await interaction.response.send_message(f"âœ… {days}æ—¥ä»¥å†…ã«æœŸé™åˆ‡ã‚Œã™ã‚‹ãƒ­ãƒ¼ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚")
            return
        
        # æ®‹ã‚Šæ—¥æ•°ã§ã‚½ãƒ¼ãƒˆ
        expiring_users.sort(key=lambda x: x['days_remaining'])
        
        embed = discord.Embed(title=f"æœŸé™åˆ‡ã‚Œé–“è¿‘ã®ãƒ­ãƒ¼ãƒ«ï¼ˆ{days}æ—¥ä»¥å†…ï¼‰", color=0xffaa00)
        
        description = ""
        for user in expiring_users[:20]:  # æœ€å¤§20ä»¶è¡¨ç¤º
            description += f"â€¢ **{user['member']}** - {user['role']} "
            description += f"(æ®‹ã‚Š{user['days_remaining']}æ—¥, ä»˜ä¸æ—¥: {user['assigned_date']})\n"
        
        if len(expiring_users) > 20:
            description += f"\n... ä»–{len(expiring_users) - 20}ä»¶"
        
        embed.description = description
        embed.set_footer(text=f"åˆè¨ˆ: {len(expiring_users)}ä»¶")
        
        await interaction.response.send_message(embed=embed)
        
    except Exception as e:
        logger.error(f"Error in list_expiring command: {e}")
        await interaction.response.send_message("âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", ephemeral=True)

@bot.tree.command(name="help", description="ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§ã‚’è¡¨ç¤º")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(title="ğŸ¤– ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§", color=0x0099ff)
    
    embed.add_field(
        name="/giveall <ãƒ­ãƒ¼ãƒ«> [é™éŸ³]", 
        value="å…¨å“¡ã«æŒ‡å®šãƒ­ãƒ¼ãƒ«ã‚’ä»˜ä¸\nç®¡ç†è€…é™å®š", 
        inline=False
    )
    embed.add_field(
        name="/test_add <ãƒ­ãƒ¼ãƒ«> [é™éŸ³]", 
        value="è‡ªåˆ†ã«ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰", 
        inline=False
    )
    embed.add_field(
        name="/status", 
        value="Botã®çŠ¶æ…‹ã¨çµ±è¨ˆã‚’è¡¨ç¤º", 
        inline=False
    )
    embed.add_field(
        name="/sync_check", 
        value="ãƒ‡ãƒ¼ã‚¿åŒæœŸã¨å‰Šé™¤ãƒã‚§ãƒƒã‚¯ã‚’æ‰‹å‹•å®Ÿè¡Œ\nç®¡ç†è€…é™å®š", 
        inline=False
    )
    embed.add_field(
        name="/list_expiring [æ—¥æ•°]", 
        value="æœŸé™åˆ‡ã‚Œé–“è¿‘ã®ãƒ­ãƒ¼ãƒ«ä¸€è¦§è¡¨ç¤º\nç®¡ç†è€…é™å®š", 
        inline=False
    )
    embed.add_field(
        name="/help", 
        value="ã“ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º", 
        inline=False
    )
    
    # è¨­å®šæƒ…å ±
    log_info = "æœªè¨­å®š"
    if LOG_CHANNEL_ID:
        channel = interaction.guild.get_channel(LOG_CHANNEL_ID)
        log_info = f"#{channel.name}" if channel else f"ID:{LOG_CHANNEL_ID}(ä¸æ˜)"
    elif LOG_CHANNEL_NAME:
        channel = discord.utils.get(interaction.guild.text_channels, name=LOG_CHANNEL_NAME)
        log_info = f"#{LOG_CHANNEL_NAME} {'âœ…' if channel else 'âŒ'}"
    
    embed.add_field(name="ğŸ“ ãƒ­ã‚°ãƒãƒ£ãƒ³ãƒãƒ«", value=log_info, inline=True)
    embed.add_field(name="â±ï¸ å‰Šé™¤ãƒã‚§ãƒƒã‚¯é–“éš”", value=f"{CHECK_INTERVAL//60}åˆ†", inline=True)
    embed.add_field(name="ğŸ”„ ãƒ‡ãƒ¼ã‚¿åŒæœŸé–“éš”", value=f"{SYNC_INTERVAL//60}åˆ†", inline=True)
    embed.add_field(name="ğŸ—‘ï¸ è‡ªå‹•å‰Šé™¤æœŸé–“", value=f"{REMOVE_AFTER//86400}æ—¥", inline=True)
    
    embed.add_field(
        name="âš ï¸ é‡è¦äº‹é …",
        value=f"â€¢ ä¸å®šæœŸèµ·å‹•å¯¾å¿œï¼ˆèµ·å‹•æ™‚+å®šæœŸãƒ‡ãƒ¼ã‚¿åŒæœŸï¼‰\nâ€¢ è‡ªå‹•å‰Šé™¤å¯¾è±¡: {', '.join(ROLES_TO_AUTO_REMOVE)}\nâ€¢ æ‰‹å‹•å‰Šé™¤ã•ã‚ŒãŸãƒ­ãƒ¼ãƒ«ã‚‚è‡ªå‹•æ¤œå‡º",
        inline=False
    )
    
    await interaction.response.send_message(embed=embed)

# ====================== ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ ======================
@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message("âŒ å¿…è¦ãªæ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚", ephemeral=True)
    elif isinstance(error, app_commands.CommandOnCooldown):
        await interaction.response.send_message(f"âŒ ã‚³ãƒãƒ³ãƒ‰ã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã§ã™ã€‚{error.retry_after:.1f}ç§’å¾Œã«å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚", ephemeral=True)
    else:
        logger.error(f"Application command error: {error}", exc_info=True)
        if not interaction.response.is_done():
            await interaction.response.send_message("âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", ephemeral=True)

# ====================== Botå®Ÿè¡Œ ======================
# â­ ãƒˆãƒ¼ã‚¯ãƒ³ã®è¨­å®šæ–¹æ³•ï¼š
# æ–¹æ³•1: ç’°å¢ƒå¤‰æ•°ã§è¨­å®šï¼ˆæ¨å¥¨ï¼‰
#   Windows: set BOT_TOKEN=YOUR_BOT_TOKEN
#   Mac/Linux: export BOT_TOKEN=YOUR_BOT_TOKEN
#
# æ–¹æ³•2: ä¸‹ã®è¡Œã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤–ã—ã¦ç›´æ¥è¨­å®šï¼ˆéæ¨å¥¨ï¼‰
# TOKEN = "YOUR_BOT_TOKEN_HERE"

TOKEN = os.environ.get("BOT_TOKEN")

if __name__ == "__main__":
    if not TOKEN:
        logger.error("BOT_TOKEN environment variable is not set")
        logger.error("ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¨­å®šã—ã¦ãã ã•ã„:")
        logger.error("  Windows: set BOT_TOKEN=ã‚ãªãŸã®ãƒˆãƒ¼ã‚¯ãƒ³")
        logger.error("  Mac/Linux: export BOT_TOKEN=ã‚ãªãŸã®ãƒˆãƒ¼ã‚¯ãƒ³")
        exit(1)
    
    try:
        logger.info("Starting bot...")
        bot.run(TOKEN)
    except discord.LoginFailure:
        logger.error("Invalid bot token")
        exit(1)
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        exit(1)
