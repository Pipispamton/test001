# -*- coding: utf-8 -*-
import discord
from discord.ext import tasks
from discord import app_commands
import json
import os
import shutil
import asyncio
import logging
import functools
from datetime import datetime, timezone, timedelta

# ====================== 基本設定 ======================
DEBUG = False

DATA_FILE = "roles_data.json"
SETTINGS_FILE = "bot_settings_debug.json" if DEBUG else "bot_settings.json"
BACKUP_DIR = "backup"

JST = timezone(timedelta(hours=9))
now_jst = lambda: datetime.now(JST)
timestamp_to_jst = lambda ts: datetime.fromtimestamp(ts, JST)

CHECK_INTERVAL = 10 if DEBUG else 600
SYNC_INTERVAL = 15 if DEBUG else 3600
BATCH_SIZE = 20 if DEBUG else 50
API_DELAY = 0.5 if DEBUG else 0.2
ROLES_TO_AUTO_REMOVE = ["注意", "警告"]
DEFAULT_REMOVE_SECONDS = {
    "注意": 15 if DEBUG else 90 * 86400,
    "警告": 15 if DEBUG else 90 * 86400
}

LOG_CHANNEL_NAME, LOG_CHANNEL_ID = "bot-logs", None

# ロギング設定
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',
                   handlers=[logging.FileHandler('bot.log', encoding='utf-8'), logging.StreamHandler()])
logger = logging.getLogger(__name__)

def format_duration(seconds: float) -> str:
    """秒数を適切な単位で文字列化"""
    seconds = int(seconds)
    if seconds < 60:
        return f"{seconds}秒"
    elif seconds < 3600:
        return f"{seconds // 60}分{seconds % 60}秒" if seconds % 60 else f"{seconds // 60}分"
    elif seconds < 86400:
        min_ = (seconds % 3600) // 60
        sec_ = seconds % 60
        return f"{seconds // 3600}時間{min_}分{sec_}秒" if min_ or sec_ else f"{seconds // 3600}時間"
    else:
        hr_ = (seconds % 86400) // 3600
        min_ = (seconds % 3600) // 60
        sec_ = seconds % 60
        val = f"{seconds // 86400}日"
        if hr_ or min_ or sec_:
            val += f"{hr_}時間" if hr_ else ""
            val += f"{min_}分" if min_ else ""
            val += f"{sec_}秒" if sec_ else ""
        return val

def parse_duration(days=0, hours=0, minutes=0, seconds=0):
    """各単位から合計秒数を得る"""
    return int(days) * 86400 + int(hours) * 3600 + int(minutes) * 60 + int(seconds)

class DataManager:
    def __init__(self):
        self.role_data = {}
        self.settings = {}
        self._lock = asyncio.Lock()
        self.load_all()
    
    def load_all(self):
        """データと設定を読み込み"""
        self.role_data = self._load_json(DATA_FILE, {})
        self.settings = self._load_json(SETTINGS_FILE, {"remove_seconds": DEFAULT_REMOVE_SECONDS.copy()})

        # 設定の補完
        if "remove_seconds" not in self.settings:
            self.settings["remove_seconds"] = DEFAULT_REMOVE_SECONDS.copy()
        for role in ROLES_TO_AUTO_REMOVE:
            if role not in self.settings["remove_seconds"]:
                self.settings["remove_seconds"][role] = DEFAULT_REMOVE_SECONDS[role]
    
    def _load_json(self, file_path, default):
        """JSONファイル読み込み"""
        if not os.path.exists(file_path):
            self._save_json(file_path, default)
            return default
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error loading {file_path}: {e}")
            return default
    
    def _save_json(self, file_path, data):
        """JSONファイル保存"""
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"Error saving {file_path}: {e}")
    
    async def save_all(self):
        """全データ保存"""
        async with self._lock:
            self._backup_data()
            self._save_json(DATA_FILE, self.role_data)
            self._save_json(SETTINGS_FILE, self.settings)
    
    def _backup_data(self):
        """データバックアップ"""
        os.makedirs(BACKUP_DIR, exist_ok=True)
        if os.path.exists(DATA_FILE):
            timestamp = now_jst().strftime("%Y%m%d_%H%M%S")
            backup_path = os.path.join(BACKUP_DIR, f"roles_data_{timestamp}.json")
            shutil.copy2(DATA_FILE, backup_path)
            self._cleanup_old_backups()
    
    def _cleanup_old_backups(self):
        """古いバックアップ削除"""
        try:
            backups = sorted([f for f in os.listdir(BACKUP_DIR) if f.startswith("roles_data_")], reverse=True)
            for old_backup in backups[10:]:
                os.remove(os.path.join(BACKUP_DIR, old_backup))
        except Exception as e:
            logger.error(f"Backup cleanup error: {e}")
    
    def get_remove_seconds(self, guild_id, user_id, role_name):
        """ユーザー個人またはデフォルト削除期間取得（秒）"""
        # 個人設定チェック
        if ("user_remove_seconds" in self.settings and 
            guild_id in self.settings["user_remove_seconds"] and 
            user_id in self.settings["user_remove_seconds"][guild_id] and 
            role_name in self.settings["user_remove_seconds"][guild_id][user_id]):
            return self.settings["user_remove_seconds"][guild_id][user_id][role_name]
        
        # デフォルト設定
        return self.settings["remove_seconds"].get(role_name, DEFAULT_REMOVE_SECONDS.get(role_name, 90 * 86400))
    
    def set_user_remove_seconds(self, guild_id, user_id, role_name, seconds):
        """個人削除期間設定（秒）"""
        if "user_remove_seconds" not in self.settings:
            self.settings["user_remove_seconds"] = {}
        if guild_id not in self.settings["user_remove_seconds"]:
            self.settings["user_remove_seconds"][guild_id] = {}
        if user_id not in self.settings["user_remove_seconds"][guild_id]:
            self.settings["user_remove_seconds"][guild_id][user_id] = {}
        
        self.settings["user_remove_seconds"][guild_id][user_id][role_name] = seconds
    
    def remove_user_setting(self, guild_id, user_id, role_name):
        """個人設定削除"""
        try:
            if (self.settings.get("user_remove_seconds", {}).get(guild_id, {})
                .get(user_id, {}).get(role_name)):
                del self.settings["user_remove_seconds"][guild_id][user_id][role_name]
                
                # 空のネストを削除
                if not self.settings["user_remove_seconds"][guild_id][user_id]:
                    del self.settings["user_remove_seconds"][guild_id][user_id]
                if not self.settings["user_remove_seconds"][guild_id]:
                    del self.settings["user_remove_seconds"][guild_id]
                if not self.settings["user_remove_seconds"]:
                    del self.settings["user_remove_seconds"]
                return True
        except KeyError:
            pass
        return False

intents = discord.Intents.default()
intents.members = True
intents.message_content = True

class RoleBot(discord.Client):
    def __init__(self):
        super().__init__(intents=intents)
        self.tree = app_commands.CommandTree(self)
        self.data = DataManager()
        self.removal_lock = asyncio.Lock()  # ロール削除用ロック
    
    async def setup_hook(self):
        await self._sync_commands()
    
    async def _sync_commands(self):
        """コマンド同期"""
        try:
            synced = await self.tree.sync()
            logger.info(f"Synced {len(synced)} commands globally")
            for guild in self.guilds:
                self.tree.copy_global_to(guild=guild)
                synced = await self.tree.sync(guild=guild)
                logger.info(f"Synced {len(synced)} commands to {guild.name}")
        except Exception as e:
            logger.error(f"Command sync error: {e}")

bot = RoleBot()

async def log_message(guild, message, level="info"):
    """ログメッセージ送信"""
    try:
        channel = None
        if LOG_CHANNEL_ID:
            channel = guild.get_channel(LOG_CHANNEL_ID)
        elif LOG_CHANNEL_NAME:
            channel = discord.utils.get(guild.text_channels, name=LOG_CHANNEL_NAME)
        
        if channel:
            emoji_map = {"info": "ℹ️", "success": "✅", "warning": "⚠️", "error": "❌"}
            emoji = emoji_map.get(level, "📝")
            await channel.send(f"{emoji} {message}"[:2000])
    except Exception as e:
        logger.error(f"Discord log error: {e}")
    
    # コンソールログ
    log_text = f"[{guild.name}] {message}"
    getattr(logger, level if level != "success" else "info")(log_text)

async def add_role_with_timestamp(member, role, silent=False, reason=None):
    """ロール付与（タイムスタンプ付き）"""
    try:
        guild_id, user_id = str(member.guild.id), str(member.id)
        
        # データ構造初期化
        if guild_id not in bot.data.role_data:
            bot.data.role_data[guild_id] = {}
        if user_id not in bot.data.role_data[guild_id]:
            bot.data.role_data[guild_id][user_id] = {}
        
        if role in member.roles:
            return True
        
        # タイムスタンプ記録
        if role.name not in bot.data.role_data[guild_id][user_id]:
            bot.data.role_data[guild_id][user_id][role.name] = now_jst().timestamp()
        
        await member.add_roles(role, reason=reason or ("自動ロール付与（静音）" if silent else "自動ロール付与"))
        await bot.data.save_all()
        return True
    except Exception as e:
        logger.error(f"Role add error for {member}: {e}")
        return False

async def sync_data_with_reality(guild, is_periodic=False):
    """データ同期"""
    try:
        now = now_jst().timestamp()
        guild_id = str(guild.id)
        
        if guild_id not in bot.data.role_data:
            bot.data.role_data[guild_id] = {}
        
        current_holders = {}
        for member in guild.members:
            if member.bot:
                continue
            user_id = str(member.id)
            for role in member.roles:
                if role.name in ROLES_TO_AUTO_REMOVE:
                    current_holders.setdefault(user_id, []).append(role.name)
        
        changes = {"removed": 0, "added": 0}
        
        users_to_remove = []
        for user_id, user_roles in list(bot.data.role_data[guild_id].items()):
            if user_id not in current_holders:
                users_to_remove.append(user_id)
                changes["removed"] += len(user_roles)
            else:
                for role_name in list(user_roles.keys()):
                    if role_name not in current_holders[user_id]:
                        del bot.data.role_data[guild_id][user_id][role_name]
                        changes["removed"] += 1
                if not bot.data.role_data[guild_id][user_id]:
                    users_to_remove.append(user_id)
        
        for user_id in users_to_remove:
            del bot.data.role_data[guild_id][user_id]
        
        for user_id, roles in current_holders.items():
            if user_id not in bot.data.role_data[guild_id]:
                bot.data.role_data[guild_id][user_id] = {}
            for role_name in roles:
                if role_name not in bot.data.role_data[guild_id][user_id]:
                    bot.data.role_data[guild_id][user_id][role_name] = now
                    changes["added"] += 1
        
        if changes["removed"] or changes["added"]:
            await bot.data.save_all()
            sync_msg = f"{'定期' if is_periodic else '起動時'}同期: 削除{changes['removed']}件, 追加{changes['added']}件"
            if is_periodic and (changes["removed"] or changes["added"]):
                await log_message(guild, sync_msg, "info")
            elif not is_periodic:
                await log_message(guild, sync_msg, "info")
        
        return changes
    except Exception as e:
        logger.error(f"Sync error for {guild.name}: {e}")
        return {"removed": 0, "added": 0}

async def process_role_removal(guild):
    """ロール削除処理"""
    guild_id = str(guild.id)
    if guild_id not in bot.data.role_data:
        return 0
    
    now = now_jst().timestamp()
    total_removed = 0

    # 排他制御で同時実行防止
    async with bot.removal_lock:
        for user_id, user_roles in list(bot.data.role_data[guild_id].items()):
            member = guild.get_member(int(user_id))
            if not member:
                del bot.data.role_data[guild_id][user_id]
                continue
            
            roles_to_remove = []
            for role_name, timestamp in list(user_roles.items()):
                if role_name not in ROLES_TO_AUTO_REMOVE or not timestamp:
                    continue
                
                role = discord.utils.get(guild.roles, name=role_name)
                if not role or role not in member.roles:
                    bot.data.role_data[guild_id][user_id].pop(role_name, None)
                    continue
                
                remove_seconds = bot.data.get_remove_seconds(guild_id, user_id, role_name)
                if now - timestamp >= remove_seconds:
                    roles_to_remove.append((role, role_name, remove_seconds, timestamp))
            
            for role, role_name, remove_seconds, timestamp in roles_to_remove:
                try:
                    # 念のため直前にロールが残ってるか確認
                    if role not in member.roles:
                        continue
                    await member.remove_roles(role, reason=f"自動削除（{format_duration(remove_seconds)}経過）")
                    assigned_time = timestamp_to_jst(timestamp)
                    sec_passed = int(now - timestamp)
                    await log_message(
                        guild,
                        f"{member.display_name} から '{role_name}' を自動削除 "
                        f"(付与: {assigned_time.strftime('%Y/%m/%d %H:%M:%S')}, 経過: {format_duration(sec_passed)})",
                        "success"
                    )
                    
                    bot.data.role_data[guild_id][user_id].pop(role_name, None)
                    total_removed += 1
                    await bot.data.save_all()
                    await asyncio.sleep(0.1)
                except Exception as e:
                    logger.error(f"Role removal error for {member}: {e}")
            
            if not bot.data.role_data[guild_id][user_id]:
                del bot.data.role_data[guild_id][user_id]
    
    return total_removed

@tasks.loop(seconds=CHECK_INTERVAL)
async def check_roles():
    """定期ロールチェック"""
    try:
        total_removed = 0
        for guild in bot.guilds:
            removed = await process_role_removal(guild)
            total_removed += removed
            await asyncio.sleep(API_DELAY)
        
        await bot.data.save_all()
        if total_removed:
            logger.info(f"Role check completed - Removed: {total_removed}")
    except Exception as e:
        logger.error(f"Role check error: {e}")

@tasks.loop(seconds=SYNC_INTERVAL)
async def sync_data_periodically():
    """定期データ同期"""
    try:
        for guild in bot.guilds:
            await sync_data_with_reality(guild, True)
            await asyncio.sleep(1)
        await bot.data.save_all()
    except Exception as e:
        logger.error(f"Periodic sync error: {e}")

@check_roles.before_loop
@sync_data_periodically.before_loop
async def wait_until_ready():
    await bot.wait_until_ready()

@bot.event
async def on_ready():
    logger.info(f"Logged in as {bot.user} - {len(bot.guilds)} guilds")
    
    for guild in bot.guilds:
        await log_message(guild, f"Bot起動完了 ({now_jst().strftime('%Y/%m/%d %H:%M:%S')} JST)", "success")
        await sync_data_with_reality(guild)
    
    await bot.data.save_all()
    
    if not check_roles.is_running():
        check_roles.start()
    if not sync_data_periodically.is_running():
        sync_data_periodically.start()
    
    await check_roles.coro()

def admin_required(func):
    """管理者権限チェックデコレータ"""
    @functools.wraps(func)
    async def wrapper(interaction, *args, **kwargs):
        if not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("❌ 管理者権限が必要です。", ephemeral=True)
            return
        return await func(interaction, *args, **kwargs)
    return wrapper

async def create_embed(title, color=0x0099ff, **fields):
    """Embed作成ヘルパー"""
    embed = discord.Embed(title=title, color=color)
    for name, value in fields.items():
        embed.add_field(name=name.replace('_', ' ').title(), value=value, inline=True)
    return embed

@bot.tree.command(name="giveall", description="全員に指定ロールを付与")
@app_commands.describe(role="付与するロール", silent="静音モード")
async def giveall(interaction: discord.Interaction, role: discord.Role, silent: bool = False):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("❌ 管理者権限が必要です。", ephemeral=True)
        return
    
    if role >= interaction.guild.me.top_role:
        await interaction.response.send_message("❌ そのロールは付与できません", ephemeral=True)
        return
    
    await interaction.response.defer(thinking=True)
    
    members = [m for m in interaction.guild.members if not m.bot and role not in m.roles]
    if not members:
        await interaction.followup.send("✅ 全員が既にロールを持っています。")
        return
    
    progress_msg = await interaction.followup.send(f"🔄 {role.name} を {len(members)} 人に付与中...")
    
    success = 0
    for i, member in enumerate(members):
        if await add_role_with_timestamp(member, role, silent, f"一括付与 by {interaction.user.display_name}"):
            success += 1
        
        if (i + 1) % BATCH_SIZE == 0:
            await progress_msg.edit(content=f"🔄 進行状況: {i + 1}/{len(members)}")
            await asyncio.sleep(API_DELAY)
        else:
            await asyncio.sleep(0.1)
    
    result = f"✅ {role.name} 付与完了！成功: {success}人"
    if role.name in ROLES_TO_AUTO_REMOVE:
        seconds = bot.data.settings["remove_seconds"].get(role.name, DEFAULT_REMOVE_SECONDS[role.name])
        result += f"\n⏰ {format_duration(seconds)}後に自動削除"
    
    await progress_msg.edit(content=result)
    await log_message(interaction.guild, f"{interaction.user.display_name} が {role.name} を一括付与: {success}人", "success")

@bot.tree.command(name="test_add", description="自分にロール付与（テスト用）")
@app_commands.describe(role="付与するロール", silent="静音モード")
async def test_add(interaction: discord.Interaction, role: discord.Role, silent: bool = False):
    if role >= interaction.guild.me.top_role:
        await interaction.response.send_message("❌ そのロールは付与できません", ephemeral=True)
        return
    
    if role in interaction.user.roles:
        await interaction.response.send_message(f"ℹ️ 既に {role.name} を持っています", ephemeral=True)
        return
    
    result = await add_role_with_timestamp(interaction.user, role, silent, "テストコマンド")
    if result:
        msg = f"✅ {role.name} を付与しました"
        if role.name in ROLES_TO_AUTO_REMOVE:
            seconds = bot.data.get_remove_seconds(str(interaction.guild.id), str(interaction.user.id), role.name)
            msg += f"\n⏰ {format_duration(seconds)}後に自動削除"
        await interaction.response.send_message(msg)
    else:
        await interaction.response.send_message("❌ 付与に失敗しました", ephemeral=True)

@bot.tree.command(name="status", description="Bot状態表示")
async def status(interaction: discord.Interaction):
    guild_id = str(interaction.guild.id)
    tracked = len(bot.data.role_data.get(guild_id, {}))
    
    embed = await create_embed(
        "Bot ステータス", 0x00ff00,
        追跡中ユーザー=f"{tracked}人",
        チェック間隔=f"{CHECK_INTERVAL//60}分",
        同期間隔=f"{SYNC_INTERVAL//60}分",
        タイムゾーン="日本時間 (JST)"
    )
    
    remove_info = []
    for role in ROLES_TO_AUTO_REMOVE:
        seconds = bot.data.settings["remove_seconds"].get(role, DEFAULT_REMOVE_SECONDS[role])
        remove_info.append(f"{role}: {format_duration(seconds)}")
    embed.add_field(name="自動削除期間", value="\n".join(remove_info), inline=False)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="set_remove_period", description="デフォルト削除期間設定（管理者限定）")
@app_commands.describe(
    role="ロール名", 
    days="日", 
    hours="時間", 
    minutes="分", 
    seconds="秒"
)
@app_commands.choices(role=[app_commands.Choice(name=r, value=r) for r in ROLES_TO_AUTO_REMOVE])
@admin_required
async def set_remove_period(
    interaction: discord.Interaction, 
    role: str, 
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0
):
    total_seconds = parse_duration(days, hours, minutes, seconds)
    if total_seconds < 0:
        await interaction.response.send_message("❌ 期間は0以上で指定してください", ephemeral=True)
        return
    
    old_seconds = bot.data.settings["remove_seconds"].get(role, DEFAULT_REMOVE_SECONDS[role])
    bot.data.settings["remove_seconds"][role] = total_seconds
    await bot.data.save_all()
    
    embed = await create_embed(
        "✅ デフォルト削除期間設定完了", 0x00ff00,
        ロール=role, 
        変更前=format_duration(old_seconds),
        変更後=format_duration(total_seconds)
    )
    await interaction.response.send_message(embed=embed)
    await log_message(interaction.guild, f"{interaction.user.display_name} が '{role}' 期間を {format_duration(old_seconds)}→{format_duration(total_seconds)}に変更", "info")

@bot.tree.command(name="set_user_period", description="個人削除期間設定（管理者限定）")
@app_commands.describe(
    user="対象ユーザー", 
    role="ロール名", 
    days="日", 
    hours="時間", 
    minutes="分", 
    seconds="秒"
)
@app_commands.choices(role=[app_commands.Choice(name=r, value=r) for r in ROLES_TO_AUTO_REMOVE])
@admin_required
async def set_user_period(
    interaction: discord.Interaction, 
    user: discord.Member, 
    role: str, 
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0
):
    total_seconds = parse_duration(days, hours, minutes, seconds)
    guild_id, user_id = str(interaction.guild.id), str(user.id)
    current_seconds = bot.data.get_remove_seconds(guild_id, user_id, role)
    default_seconds = bot.data.settings["remove_seconds"].get(role, DEFAULT_REMOVE_SECONDS[role])
    
    if total_seconds == 0:
        removed = bot.data.remove_user_setting(guild_id, user_id, role)
        title = "✅ 個人設定削除完了" if removed else "ℹ️ 個人設定なし"
        change = f"{format_duration(current_seconds)} → デフォルト({format_duration(default_seconds)})" if removed else "変更なし"
    else:
        bot.data.set_user_remove_seconds(guild_id, user_id, role, total_seconds)
        title = "✅ 個人削除期間設定完了"
        change = f"{format_duration(current_seconds)} → {format_duration(total_seconds)}"
    
    await bot.data.save_all()
    embed = await create_embed(title, 0x00ff00,
                              ユーザー=user.display_name, ロール=role, 変更=change)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="show_user_period", description="個人削除期間表示")
@app_commands.describe(user="対象ユーザー（省略時は自分）")
async def show_user_period(interaction: discord.Interaction, user: discord.Member = None):
    if user is None:
        user = interaction.user
    
    guild_id, user_id = str(interaction.guild.id), str(user.id)
    embed = discord.Embed(title=f"🗑️ {user.display_name} の削除期間設定", color=0x0099ff)
    
    for role_name in ROLES_TO_AUTO_REMOVE:
        personal_seconds = None
        default_seconds = bot.data.settings["remove_seconds"].get(role_name, DEFAULT_REMOVE_SECONDS[role_name])
        
        if (bot.data.settings.get("user_remove_seconds", {}).get(guild_id, {})
            .get(user_id, {}).get(role_name)):
            personal_seconds = bot.data.settings["user_remove_seconds"][guild_id][user_id][role_name]
        
        value = (
            f"**{format_duration(personal_seconds)}** (個人設定)\nデフォルト: {format_duration(default_seconds)}"
            if personal_seconds else f"{format_duration(default_seconds)} (デフォルト)"
        )
        embed.add_field(name=role_name, value=value, inline=True)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="sync_check", description="手動同期・チェック実行（管理者限定）")
@admin_required
async def sync_check(interaction: discord.Interaction):
    await interaction.response.defer(thinking=True)
    
    await sync_data_with_reality(interaction.guild)
    removed = await process_role_removal(interaction.guild)
    await bot.data.save_all()
    
    await interaction.followup.send(f"✅ 手動同期完了\n削除されたロール: {removed}個")
    await log_message(interaction.guild, f"{interaction.user.display_name} が手動同期実行: {removed}個削除", "info")

@bot.tree.command(name="help", description="コマンド一覧表示")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(title="🤖 コマンド一覧", color=0x0099ff)
    commands_info = {
        "/giveall": "全員にロール付与（管理者限定）",
        "/test_add": "自分にロール付与（テスト用）",
        "/status": "Bot状態表示",
        "/set_remove_period": "デフォルト削除期間設定（管理者限定）",
        "/set_user_period": "個人削除期間設定（管理者限定）",
        "/show_user_period": "個人削除期間表示",
        "/sync_check": "手動同期・チェック（管理者限定）"
    }
    
    for cmd, desc in commands_info.items():
        embed.add_field(name=cmd, value=desc, inline=False)
    
    embed.add_field(name="⚠️ 重要事項", 
                   value=f"• 自動削除対象: {', '.join(ROLES_TO_AUTO_REMOVE)}\n• 不定期起動対応\n• 個人別削除期間設定可能", 
                   inline=False)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message("❌ 必要な権限がありません。", ephemeral=True)
    elif isinstance(error, app_commands.CommandOnCooldown):
        await interaction.response.send_message(f"❌ コマンドはクールダウン中です。{error.retry_after:.1f}秒後に再試行してください。", ephemeral=True)
    else:
        logger.error(f"Application command error: {error}", exc_info=True)
        if not interaction.response.is_done():
            await interaction.response.send_message("❌ 予期しないエラーが発生しました。", ephemeral=True)

TOKEN = os.environ.get("BOT_TOKEN")

if __name__ == "__main__":
    if not TOKEN:
        logger.error("BOT_TOKEN environment variable is not set")
        logger.error("トークンを設定してください:")
        logger.error("  Windows: set BOT_TOKEN=あなたのトークン")
        logger.error("  Mac/Linux: export BOT_TOKEN=あなたのトークン")
        exit(1)
    
    try:
        logger.info("Starting bot...")
        bot.run(TOKEN)
    except discord.LoginFailure:
        logger.error("Invalid bot token")
        exit(1)
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        exit(1)
