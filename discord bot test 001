# -*- coding: utf-8 -*-
import discord
from discord.ext import tasks
from discord import app_commands
import json
import os
import shutil
import asyncio
import logging
import functools
from datetime import datetime, timezone, timedelta
from discord.ui import Modal, TextInput, View, Button

DEBUG = True

DATA_FILE = "roles_data.json"
SETTINGS_FILE = "bot_settings_debug.json" if DEBUG else "bot_settings.json"
ROLE_HISTORY_FILE = "role_add_history.json"
LOG_CHANNEL_FILE = "log_channel_settings.json"
BACKUP_DIR = "backup"

JST = timezone(timedelta(hours=9))
now_jst = lambda: datetime.now(JST)
timestamp_to_jst = lambda ts: datetime.fromtimestamp(ts, JST)

CHECK_INTERVAL = 10 if DEBUG else 600
SYNC_INTERVAL = 15 if DEBUG else 3600
BATCH_SIZE = 20 if DEBUG else 50
API_DELAY = 0.5 if DEBUG else 0.2
ROLES_TO_AUTO_REMOVE = ["æ³¨æ„", "è­¦å‘Š"]
DEFAULT_REMOVE_SECONDS = {r: (15 if DEBUG else 90 * 86400) for r in ROLES_TO_AUTO_REMOVE}

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("bot.log", encoding="utf-8"), logging.StreamHandler()],
)
logger = logging.getLogger(__name__)

def format_duration(seconds: float) -> str:
    seconds = int(seconds)
    if seconds < 60:
        return f"{seconds}ç§’"
    elif seconds < 3600:
        return f"{seconds // 60}åˆ†{seconds % 60}ç§’" if seconds % 60 else f"{seconds // 60}åˆ†"
    elif seconds < 86400:
        m = (seconds % 3600) // 60
        s = seconds % 60
        return f"{seconds // 3600}æ™‚é–“{m}åˆ†{s}ç§’" if m or s else f"{seconds // 3600}æ™‚é–“"
    else:
        h = (seconds % 86400) // 3600
        m = (seconds % 3600) // 60
        s = seconds % 60
        val = f"{seconds // 86400}æ—¥"
        if h or m or s:
            if h: val += f"{h}æ™‚é–“"
            if m: val += f"{m}åˆ†"
            if s: val += f"{s}ç§’"
        return val

def parse_duration(days=0, hours=0, minutes=0, seconds=0):
    return int(days) * 86400 + int(hours) * 3600 + int(minutes) * 60 + int(seconds)

class DataManager:
    def __init__(self):
        self.role_data = {}
        self.settings = {}
        self.role_add_history = {}
        self.guild_log_channels = {}
        self._lock = asyncio.Lock()
        self.load_all()

    def load_all(self):
        self.role_data = self._load_json(DATA_FILE, {})
        self.settings = self._load_json(SETTINGS_FILE, {"remove_seconds": DEFAULT_REMOVE_SECONDS.copy()})
        self.role_add_history = self._load_json(ROLE_HISTORY_FILE, {})
        self.guild_log_channels = self._load_json(LOG_CHANNEL_FILE, {})
        # å±¥æ­´å¤‰æ›
        for g, users in self.role_add_history.items():
            for u, roles in users.items():
                for r, hist in roles.items():
                    if hist and isinstance(hist[0], float):
                        self.role_add_history[g][u][r] = [{"timestamp": ts, "reason": ""} for ts in hist]
        self.settings.setdefault("remove_seconds", DEFAULT_REMOVE_SECONDS.copy())
        for r in ROLES_TO_AUTO_REMOVE:
            self.settings["remove_seconds"].setdefault(r, DEFAULT_REMOVE_SECONDS[r])

    def _load_json(self, file_path, default):
        if not os.path.exists(file_path):
            self._save_json(file_path, default)
            return default
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error loading {file_path}: {e}")
            return default

    def _save_json(self, file_path, data):
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"Error saving {file_path}: {e}")

    async def save_all(self):
        async with self._lock:
            self._backup_data()
            self._save_json(DATA_FILE, self.role_data)
            self._save_json(SETTINGS_FILE, self.settings)
            self._save_json(ROLE_HISTORY_FILE, self.role_add_history)
            self._save_json(LOG_CHANNEL_FILE, self.guild_log_channels)

    def _backup_data(self):
        os.makedirs(BACKUP_DIR, exist_ok=True)
        if os.path.exists(DATA_FILE):
            ts = now_jst().strftime("%Y%m%d_%H%M%S")
            shutil.copy2(DATA_FILE, os.path.join(BACKUP_DIR, f"roles_data_{ts}.json"))
            self._cleanup_old_backups()

    def _cleanup_old_backups(self):
        try:
            backups = sorted([f for f in os.listdir(BACKUP_DIR) if f.startswith("roles_data_")], reverse=True)
            for old_backup in backups[10:]:
                os.remove(os.path.join(BACKUP_DIR, old_backup))
        except Exception as e:
            logger.error(f"Backup cleanup error: {e}")

    def get_remove_seconds(self, guild_id, user_id, role_name):
        user_setting = (
            self.settings.get("user_remove_seconds", {}).get(guild_id, {})
            .get(user_id, {}).get(role_name)
        )
        if user_setting is not None:
            return user_setting
        return self.settings["remove_seconds"].get(role_name, DEFAULT_REMOVE_SECONDS.get(role_name, 90 * 86400))

    def set_user_remove_seconds(self, guild_id, user_id, role_name, seconds):
        self.settings.setdefault("user_remove_seconds", {}).setdefault(guild_id, {}).setdefault(user_id, {})[role_name] = seconds

    def remove_user_setting(self, guild_id, user_id, role_name):
        try:
            user_roles = self.settings.get("user_remove_seconds", {}).get(guild_id, {}).get(user_id, {})
            if role_name in user_roles:
                del user_roles[role_name]
                if not user_roles:
                    del self.settings["user_remove_seconds"][guild_id][user_id]
                if not self.settings["user_remove_seconds"][guild_id]:
                    del self.settings["user_remove_seconds"][guild_id]
                if not self.settings["user_remove_seconds"]:
                    del self.settings["user_remove_seconds"]
                return True
        except KeyError:
            pass
        return False

    def add_role_history(self, guild_id, user_id, role_name, timestamp):
        if role_name not in ROLES_TO_AUTO_REMOVE:
            return
        self.role_add_history.setdefault(guild_id, {}).setdefault(user_id, {}).setdefault(role_name, []).append({
            "timestamp": timestamp,
            "reason": ""
        })

    def edit_role_history_reason(self, guild_id, user_id, role_name, index, reason):
        try:
            self.role_add_history[guild_id][user_id][role_name][index]["reason"] = reason
            return True
        except Exception:
            return False

intents = discord.Intents.default()
intents.members = True
intents.message_content = True

class RoleBot(discord.Client):
    def __init__(self):
        super().__init__(intents=intents)
        self.tree = app_commands.CommandTree(self)
        self.data = DataManager()
        self.removal_lock = asyncio.Lock()

    async def setup_hook(self):
        await self._sync_commands()

    async def _sync_commands(self):
        try:
            synced = await self.tree.sync()
            logger.info(f"Synced {len(synced)} commands globally")
            for guild in self.guilds:
                self.tree.copy_global_to(guild=guild)
                synced = await self.tree.sync(guild=guild)
                logger.info(f"Synced {len(synced)} commands to {guild.name}")
        except Exception as e:
            logger.error(f"Command sync error: {e}")

bot = RoleBot()

async def log_message(guild, message, level="info"):
    channel_id = bot.data.guild_log_channels.get(str(guild.id))
    channel = guild.get_channel(channel_id) if channel_id else None
    if channel is None:
        channel = next((ch for ch in guild.text_channels if ch.permissions_for(guild.me).send_messages), None)
    try:
        if channel:
            emoji = {"info": "â„¹ï¸", "success": "âœ…", "warning": "âš ï¸", "error": "âŒ"}.get(level, "ğŸ“")
            await channel.send(f"{emoji} {message}"[:2000])
    except Exception as e:
        logger.error(f"Discord log error: {e}")
    getattr(logger, level if level != "success" else "info")(f"[{guild.name}] {message}")

async def add_role_with_timestamp(member, role, reason=None):
    try:
        guild_id, user_id = str(member.guild.id), str(member.id)
        bot.data.role_data.setdefault(guild_id, {}).setdefault(user_id, {})
        if role in member.roles:
            return True
        now_ts = now_jst().timestamp()
        if role.name in ROLES_TO_AUTO_REMOVE and role.name not in bot.data.role_data[guild_id][user_id]:
            bot.data.role_data[guild_id][user_id][role.name] = now_ts
            bot.data.add_role_history(guild_id, user_id, role.name, now_ts)
        elif role.name not in bot.data.role_data[guild_id][user_id]:
            bot.data.role_data[guild_id][user_id][role.name] = now_ts
        await member.add_roles(role, reason=reason or "è‡ªå‹•ãƒ­ãƒ¼ãƒ«ä»˜ä¸")
        await bot.data.save_all()
        return True
    except Exception as e:
        logger.error(f"Role add error for {member}: {e}")
        return False

async def sync_data_with_reality(guild, is_periodic=False):
    try:
        now = now_jst().timestamp()
        guild_id = str(guild.id)
        bot.data.role_data.setdefault(guild_id, {})
        current_holders = {}
        for member in guild.members:
            if member.bot:
                continue
            user_id = str(member.id)
            for role in member.roles:
                if role.name in ROLES_TO_AUTO_REMOVE:
                    current_holders.setdefault(user_id, []).append(role.name)
        changes = {"removed": 0, "added": 0}
        users_to_remove = []
        for user_id, user_roles in list(bot.data.role_data[guild_id].items()):
            if user_id not in current_holders:
                users_to_remove.append(user_id)
                changes["removed"] += len(user_roles)
            else:
                for role_name in list(user_roles.keys()):
                    if role_name not in current_holders[user_id]:
                        del bot.data.role_data[guild_id][user_id][role_name]
                        changes["removed"] += 1
                if not bot.data.role_data[guild_id][user_id]:
                    users_to_remove.append(user_id)
        for user_id in users_to_remove:
            del bot.data.role_data[guild_id][user_id]
        for user_id, roles in current_holders.items():
            bot.data.role_data.setdefault(guild_id, {}).setdefault(user_id, {})
            for role_name in roles:
                if role_name not in bot.data.role_data[guild_id][user_id]:
                    bot.data.role_data[guild_id][user_id][role_name] = now
                    if role_name in ROLES_TO_AUTO_REMOVE:
                        bot.data.add_role_history(guild_id, user_id, role_name, now)
                    changes["added"] += 1
        if changes["removed"] or changes["added"]:
            await bot.data.save_all()
            sync_msg = f"{'å®šæœŸ' if is_periodic else 'èµ·å‹•æ™‚'}åŒæœŸ: å‰Šé™¤{changes['removed']}ä»¶, è¿½åŠ {changes['added']}ä»¶"
            await log_message(guild, sync_msg, "info")
        return changes
    except Exception as e:
        logger.error(f"Sync error for {guild.name}: {e}")
        return {"removed": 0, "added": 0}

async def process_role_removal(guild):
    guild_id = str(guild.id)
    if guild_id not in bot.data.role_data:
        return 0
    now = now_jst().timestamp()
    total_removed = 0
    async with bot.removal_lock:
        for user_id, user_roles in list(bot.data.role_data[guild_id].items()):
            member = guild.get_member(int(user_id))
            if not member:
                del bot.data.role_data[guild_id][user_id]
                continue
            roles_to_remove = []
            for role_name, timestamp in list(user_roles.items()):
                if role_name not in ROLES_TO_AUTO_REMOVE or not timestamp:
                    continue
                role = discord.utils.get(guild.roles, name=role_name)
                if not role or role not in member.roles:
                    bot.data.role_data[guild_id][user_id].pop(role_name, None)
                    continue
                remove_seconds = bot.data.get_remove_seconds(guild_id, user_id, role_name)
                if now - timestamp >= remove_seconds:
                    roles_to_remove.append((role, role_name, remove_seconds, timestamp))
            for role, role_name, remove_seconds, timestamp in roles_to_remove:
                try:
                    if role not in member.roles:
                        continue
                    await member.remove_roles(role, reason=f"è‡ªå‹•å‰Šé™¤ï¼ˆ{format_duration(remove_seconds)}çµŒéï¼‰")
                    assigned_time = timestamp_to_jst(timestamp)
                    sec_passed = int(now - timestamp)
                    await log_message(
                        guild,
                        f"{member.display_name} ã‹ã‚‰ '{role_name}' ã‚’è‡ªå‹•å‰Šé™¤ "
                        f"(ä»˜ä¸: {assigned_time.strftime('%Y/%m/%d %H:%M:%S')}, çµŒé: {format_duration(sec_passed)})",
                        "success"
                    )
                    bot.data.role_data[guild_id][user_id].pop(role_name, None)
                    total_removed += 1
                    await bot.data.save_all()
                    await asyncio.sleep(0.1)
                except Exception as e:
                    logger.error(f"Role removal error for {member}: {e}")
            if not bot.data.role_data[guild_id][user_id]:
                del bot.data.role_data[guild_id][user_id]
    return total_removed

@tasks.loop(seconds=CHECK_INTERVAL)
async def check_roles():
    try:
        total_removed = 0
        for guild in bot.guilds:
            removed = await process_role_removal(guild)
            total_removed += removed
            await asyncio.sleep(API_DELAY)
        await bot.data.save_all()
        if total_removed:
            logger.info(f"Role check completed - Removed: {total_removed}")
    except Exception as e:
        logger.error(f"Role check error: {e}")

@tasks.loop(seconds=SYNC_INTERVAL)
async def sync_data_periodically():
    try:
        for guild in bot.guilds:
            await sync_data_with_reality(guild, True)
            await asyncio.sleep(1)
        await bot.data.save_all()
    except Exception as e:
        logger.error(f"Periodic sync error: {e}")

@check_roles.before_loop
@sync_data_periodically.before_loop
async def wait_until_ready():
    await bot.wait_until_ready()

@bot.event
async def on_ready():
    logger.info(f"Logged in as {bot.user} - {len(bot.guilds)} guilds")
    for guild in bot.guilds:
        await log_message(guild, f"Botèµ·å‹•å®Œäº† ({now_jst().strftime('%Y/%m/%d %H:%M:%S')} JST)", "success")
        await sync_data_with_reality(guild)
    await bot.data.save_all()
    if not check_roles.is_running():
        check_roles.start()
    if not sync_data_periodically.is_running():
        sync_data_periodically.start()
    await check_roles.coro()

def admin_required(func):
    @functools.wraps(func)
    async def wrapper(interaction, *args, **kwargs):
        if not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("âŒ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚", ephemeral=True)
            return
        return await func(interaction, *args, **kwargs)
    return wrapper

async def create_embed(title, color=0x0099ff, **fields):
    embed = discord.Embed(title=title, color=color)
    for name, value in fields.items():
        embed.add_field(name=name.replace('_', ' ').title(), value=value, inline=True)
    return embed

class ReasonModal(Modal, title="ç†ç”±ã‚’ç·¨é›†"):
    def __init__(self, guild_id, user_id, role_name, index, old_reason, view_instance):
        super().__init__()
        self.guild_id = guild_id
        self.user_id = user_id
        self.role_name = role_name
        self.index = index
        self.view_instance = view_instance
        self.reason_input = TextInput(
            label="ç†ç”±",
            style=discord.TextStyle.long,
            default=old_reason or "",
            required=False,
            max_length=500
        )
        self.add_item(self.reason_input)

    async def on_submit(self, interaction: discord.Interaction):
        reason = self.reason_input.value.strip()
        success = bot.data.edit_role_history_reason(self.guild_id, self.user_id, self.role_name, self.index, reason)
        if success:
            await bot.data.save_all()
            await interaction.response.send_message(
                f"âœ… ç†ç”±ã‚’æ›´æ–°ã—ã¾ã—ãŸ\n**{self.role_name} {self.index+1}å›ç›®:** {reason or '(ç†ç”±ãªã—)'}",
                ephemeral=True
            )
            await self.view_instance.update_view(interaction.message)
        else:
            await interaction.response.send_message("âŒ ç†ç”±ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ", ephemeral=True)

class EditReasonButton(Button):
    def __init__(self, guild_id, user_id, role_name, index, old_reason, view_instance, display_info):
        label = f"{'âœï¸' if old_reason else 'â•'} {display_info}"
        super().__init__(label=label, style=discord.ButtonStyle.secondary)
        self.guild_id = guild_id
        self.user_id = user_id
        self.role_name = role_name
        self.index = index
        self.old_reason = old_reason
        self.view_instance = view_instance

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_modal(
            ReasonModal(self.guild_id, self.user_id, self.role_name, self.index, self.old_reason, self.view_instance)
        )

class NavigationButton(Button):
    def __init__(self, direction, disabled=False):
        super().__init__(
            emoji="â—€ï¸" if direction == "prev" else "â–¶ï¸",
            label="å‰ã®ãƒšãƒ¼ã‚¸" if direction == "prev" else "æ¬¡ã®ãƒšãƒ¼ã‚¸",
            style=discord.ButtonStyle.primary,
            disabled=disabled
        )
        self.direction = direction

    async def callback(self, interaction: discord.Interaction):
        view = self.view
        if self.direction == "prev" and view.current_page > 0:
            view.current_page -= 1
        elif self.direction == "next" and view.current_page < view.total_pages - 1:
            view.current_page += 1
        await view.update_view(interaction.message, interaction)

class RoleHistoryView(View):
    def __init__(self, guild_id, user_id, user_name, history):
        super().__init__(timeout=600)
        self.guild_id = guild_id
        self.user_id = user_id
        self.user_name = user_name
        self.history = history
        self.current_page = 0
        self.items_per_role_per_page = 5
        self._calc_pages()
        self.update_buttons()

    def _calc_pages(self):
        self.role_pages = {
            r: (len(items) + self.items_per_role_per_page - 1) // self.items_per_role_per_page
            for r, items in self.history.items()
        }
        self.total_pages = max(self.role_pages.values()) if self.role_pages else 1

    def get_current_page_data(self):
        page_data = {}
        for role_name, items in self.history.items():
            sorted_items = sorted(items, key=lambda x: x['timestamp'], reverse=True)
            start_idx = self.current_page * self.items_per_role_per_page
            end_idx = start_idx + self.items_per_role_per_page
            page_items = sorted_items[start_idx:end_idx] if start_idx < len(sorted_items) else []
            if page_items:
                page_items_with_index = [
                    {
                        'item': item,
                        'original_index': items.index(item),
                        'display_number': items.index(item) + 1
                    }
                    for item in page_items
                ]
                page_data[role_name] = {
                    'items': page_items_with_index,
                    'start_index': start_idx,
                    'total_count': len(items)
                }
        return page_data

    def update_buttons(self):
        self.clear_items()
        page_data = self.get_current_page_data()
        self.add_item(NavigationButton("prev", self.current_page == 0))
        self.add_item(NavigationButton("next", self.current_page >= self.total_pages - 1))
        role_rows = {"æ³¨æ„": 1, "è­¦å‘Š": 2}
        for role_name, role_data in page_data.items():
            if role_name not in role_rows:
                continue
            for item_data in role_data['items'][:self.items_per_role_per_page]:
                entry = item_data['item']
                original_index = item_data['original_index']
                display_num = item_data['display_number']
                display_info = f"{role_name} {display_num}å›ç›®"
                b = EditReasonButton(self.guild_id, self.user_id, role_name, original_index, entry["reason"], self, display_info)
                b.row = role_rows[role_name]
                self.add_item(b)

    def create_embed(self):
        embed = discord.Embed(
            title=f"ğŸ“ {self.user_name} ã®ãƒ­ãƒ¼ãƒ«ä»˜ä¸å±¥æ­´ï¼ˆæ³¨æ„ãƒ»è­¦å‘Šã®ã¿ï¼‰",
            color=0x0099ff
        )
        page_data = self.get_current_page_data()
        if not page_data:
            embed.description = "ã“ã®ãƒšãƒ¼ã‚¸ã«ã¯è¡¨ç¤ºã™ã‚‹å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
            return embed
        for role_name, role_data in page_data.items():
            items_with_index = role_data['items']
            start_index = role_data['start_index']
            total_count = role_data['total_count']
            lines = []
            for item_data in items_with_index:
                entry = item_data['item']
                actual_count = item_data['display_number']
                dt = timestamp_to_jst(entry["timestamp"]).strftime('%Y/%m/%d %H:%M:%S')
                reason = entry["reason"] or "(ç†ç”±æœªè¨˜å…¥)"
                lines.append(f"**{actual_count}å›ç›®:** {dt}\nã€€ç†ç”±ï¼š{reason}")
            display_start = start_index + 1
            display_end = start_index + len(items_with_index)
            page_info = f"ï¼ˆæ–°ã—ã„é † {display_start}-{display_end}/{total_count}ä»¶ï¼‰"
            field_name = f"{role_name} {page_info}"
            embed.add_field(name=field_name, value="\n".join(lines), inline=False)
        if self.total_pages > 1:
            embed.set_footer(text=f"ãƒšãƒ¼ã‚¸ {self.current_page + 1}/{self.total_pages} ï¼ˆæ–°ã—ã„é †ï¼‰")
        return embed

    async def update_view(self, message, interaction=None):
        self.history = bot.data.role_add_history.get(self.guild_id, {}).get(self.user_id, {})
        self._calc_pages()
        if self.current_page >= self.total_pages:
            self.current_page = max(0, self.total_pages - 1)
        self.update_buttons()
        embed = self.create_embed()
        if interaction:
            await interaction.response.edit_message(embed=embed, view=self)
        else:
            await message.edit(embed=embed, view=self)

    async def on_timeout(self):
        for item in self.children:
            item.disabled = True

@bot.tree.command(name="show_role_history", description="æŒ‡å®šãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«ä»˜ä¸å±¥æ­´è¡¨ç¤ºï¼ˆæ³¨æ„ãƒ»è­¦å‘Šã®ã¿ã€‚ç†ç”±ç·¨é›†æ©Ÿèƒ½ä»˜ãï¼‰")
@app_commands.describe(user="å±¥æ­´ã‚’è¡¨ç¤ºã—ãŸã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆçœç•¥æ™‚ã¯è‡ªåˆ†ï¼‰")
async def show_role_history(interaction: discord.Interaction, user: discord.Member = None):
    user = user or interaction.user
    guild_id, user_id = str(interaction.guild.id), str(user.id)
    history = bot.data.role_add_history.get(guild_id, {}).get(user_id, {})
    if not history:
        embed = discord.Embed(
            title=f"ğŸ“ {user.display_name} ã®ãƒ­ãƒ¼ãƒ«ä»˜ä¸å±¥æ­´ï¼ˆæ³¨æ„ãƒ»è­¦å‘Šã®ã¿ï¼‰",
            description="å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
            color=0x0099ff
        )
        await interaction.response.send_message(embed=embed)
        return
    view = RoleHistoryView(guild_id, user_id, user.display_name, history)
    embed = view.create_embed()
    await interaction.response.send_message(embed=embed, view=view)

@bot.tree.command(name="giveall", description="å…¨å“¡ã«æŒ‡å®šãƒ­ãƒ¼ãƒ«ã‚’ä»˜ä¸ï¼ˆç®¡ç†è€…é™å®šï¼‰")
@app_commands.describe(role="ä»˜ä¸ã™ã‚‹ãƒ­ãƒ¼ãƒ«")
async def giveall(interaction: discord.Interaction, role: discord.Role):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("âŒ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚", ephemeral=True)
        return
    if role >= interaction.guild.me.top_role:
        await interaction.response.send_message("âŒ ãã®ãƒ­ãƒ¼ãƒ«ã¯ä»˜ä¸ã§ãã¾ã›ã‚“", ephemeral=True)
        return
    await interaction.response.defer(thinking=True)
    members = [m for m in interaction.guild.members if not m.bot and role not in m.roles]
    if not members:
        await interaction.followup.send("âœ… å…¨å“¡ãŒæ—¢ã«ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã¾ã™ã€‚")
        return
    progress_msg = await interaction.followup.send(f"ğŸ”„ {role.name} ã‚’ {len(members)} äººã«ä»˜ä¸ä¸­...")
    success = 0
    for i, member in enumerate(members):
        if await add_role_with_timestamp(member, role, f"ä¸€æ‹¬ä»˜ä¸ by {interaction.user.display_name}"):
            success += 1
        if (i + 1) % BATCH_SIZE == 0:
            await progress_msg.edit(content=f"ğŸ”„ é€²è¡ŒçŠ¶æ³: {i + 1}/{len(members)}")
            await asyncio.sleep(API_DELAY)
        else:
            await asyncio.sleep(0.1)
    result = f"âœ… {role.name} ä»˜ä¸å®Œäº†ï¼æˆåŠŸ: {success}äºº"
    if role.name in ROLES_TO_AUTO_REMOVE:
        seconds = bot.data.settings["remove_seconds"].get(role.name, DEFAULT_REMOVE_SECONDS[role.name])
        result += f"\nâ° {format_duration(seconds)}å¾Œã«è‡ªå‹•å‰Šé™¤"
    await progress_msg.edit(content=result)
    await log_message(interaction.guild, f"{interaction.user.display_name} ãŒ {role.name} ã‚’ä¸€æ‹¬ä»˜ä¸: {success}äºº", "success")

@bot.tree.command(name="test_add", description="è‡ªåˆ†ã«ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰")
@app_commands.describe(role="ä»˜ä¸ã™ã‚‹ãƒ­ãƒ¼ãƒ«")
async def test_add(interaction: discord.Interaction, role: discord.Role):
    if role >= interaction.guild.me.top_role:
        await interaction.response.send_message("âŒ ãã®ãƒ­ãƒ¼ãƒ«ã¯ä»˜ä¸ã§ãã¾ã›ã‚“", ephemeral=True)
        return
    if role in interaction.user.roles:
        await interaction.response.send_message(f"â„¹ï¸ æ—¢ã« {role.name} ã‚’æŒã£ã¦ã„ã¾ã™", ephemeral=True)
        return
    result = await add_role_with_timestamp(interaction.user, role, "ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰")
    if result:
        msg = f"âœ… {role.name} ã‚’ä»˜ä¸ã—ã¾ã—ãŸ"
        if role.name in ROLES_TO_AUTO_REMOVE:
            seconds = bot.data.get_remove_seconds(str(interaction.guild.id), str(interaction.user.id), role.name)
            msg += f"\nâ° {format_duration(seconds)}å¾Œã«è‡ªå‹•å‰Šé™¤"
        await interaction.response.send_message(msg)
    else:
        await interaction.response.send_message("âŒ ä»˜ä¸ã«å¤±æ•—ã—ã¾ã—ãŸ", ephemeral=True)

@bot.tree.command(name="status", description="BotçŠ¶æ…‹è¡¨ç¤º")
async def status(interaction: discord.Interaction):
    guild_id = str(interaction.guild.id)
    tracked = len(bot.data.role_data.get(guild_id, {}))
    embed = await create_embed(
        "Bot ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", 0x00ff00,
        è¿½è·¡ä¸­ãƒ¦ãƒ¼ã‚¶ãƒ¼=f"{tracked}äºº",
        ãƒã‚§ãƒƒã‚¯é–“éš”=f"{CHECK_INTERVAL//60}åˆ†",
        åŒæœŸé–“éš”=f"{SYNC_INTERVAL//60}åˆ†",
        ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³="æ—¥æœ¬æ™‚é–“ (JST)"
    )
    remove_info = [f"{role}: {format_duration(bot.data.settings['remove_seconds'].get(role, DEFAULT_REMOVE_SECONDS[role]))}" for role in ROLES_TO_AUTO_REMOVE]
    embed.add_field(name="è‡ªå‹•å‰Šé™¤æœŸé–“", value="\n".join(remove_info), inline=False)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="set_remove_period", description="ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰")
@app_commands.describe(role="ãƒ­ãƒ¼ãƒ«å", days="æ—¥", hours="æ™‚é–“", minutes="åˆ†", seconds="ç§’")
@app_commands.choices(role=[app_commands.Choice(name=r, value=r) for r in ROLES_TO_AUTO_REMOVE])
@admin_required
async def set_remove_period(
    interaction: discord.Interaction,
    role: str,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0
):
    total_seconds = parse_duration(days, hours, minutes, seconds)
    if total_seconds < 0:
        await interaction.response.send_message("âŒ æœŸé–“ã¯0ä»¥ä¸Šã§æŒ‡å®šã—ã¦ãã ã•ã„", ephemeral=True)
        return
    old_seconds = bot.data.settings["remove_seconds"].get(role, DEFAULT_REMOVE_SECONDS[role])
    bot.data.settings["remove_seconds"][role] = total_seconds
    await bot.data.save_all()
    embed = await create_embed(
        "âœ… ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‰Šé™¤æœŸé–“è¨­å®šå®Œäº†", 0x00ff00,
        ãƒ­ãƒ¼ãƒ«=role,
        å¤‰æ›´å‰=format_duration(old_seconds),
        å¤‰æ›´å¾Œ=format_duration(total_seconds)
    )
    await interaction.response.send_message(embed=embed)
    await log_message(interaction.guild, f"{interaction.user.display_name} ãŒ '{role}' æœŸé–“ã‚’ {format_duration(old_seconds)}â†’{format_duration(total_seconds)}ã«å¤‰æ›´", "info")

@bot.tree.command(name="set_user_period", description="å€‹äººå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰")
@app_commands.describe(user="å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼", role="ãƒ­ãƒ¼ãƒ«å", days="æ—¥", hours="æ™‚é–“", minutes="åˆ†", seconds="ç§’")
@app_commands.choices(role=[app_commands.Choice(name=r, value=r) for r in ROLES_TO_AUTO_REMOVE])
@admin_required
async def set_user_period(
    interaction: discord.Interaction,
    user: discord.Member,
    role: str,
    days: int = 0,
    hours: int = 0,
    minutes: int = 0,
    seconds: int = 0
):
    total_seconds = parse_duration(days, hours, minutes, seconds)
    guild_id, user_id = str(interaction.guild.id), str(user.id)
    current_seconds = bot.data.get_remove_seconds(guild_id, user_id, role)
    default_seconds = bot.data.settings["remove_seconds"].get(role, DEFAULT_REMOVE_SECONDS[role])
    if total_seconds == 0:
        removed = bot.data.remove_user_setting(guild_id, user_id, role)
        title = "âœ… å€‹äººè¨­å®šå‰Šé™¤å®Œäº†" if removed else "â„¹ï¸ å€‹äººè¨­å®šãªã—"
        change = f"{format_duration(current_seconds)} â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ({format_duration(default_seconds)})" if removed else "å¤‰æ›´ãªã—"
    else:
        bot.data.set_user_remove_seconds(guild_id, user_id, role, total_seconds)
        title = "âœ… å€‹äººå‰Šé™¤æœŸé–“è¨­å®šå®Œäº†"
        change = f"{format_duration(current_seconds)} â†’ {format_duration(total_seconds)}"
    await bot.data.save_all()
    embed = await create_embed(title, 0x00ff00,
                              ãƒ¦ãƒ¼ã‚¶ãƒ¼=user.display_name, ãƒ­ãƒ¼ãƒ«=role, å¤‰æ›´=change)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="show_user_period", description="å€‹äººå‰Šé™¤æœŸé–“è¡¨ç¤º")
@app_commands.describe(user="å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆçœç•¥æ™‚ã¯è‡ªåˆ†ï¼‰")
async def show_user_period(interaction: discord.Interaction, user: discord.Member = None):
    user = user or interaction.user
    guild_id, user_id = str(interaction.guild.id), str(user.id)
    embed = discord.Embed(title=f"ğŸ—‘ï¸ {user.display_name} ã®å‰Šé™¤æœŸé–“è¨­å®š", color=0x0099ff)
    for role_name in ROLES_TO_AUTO_REMOVE:
        personal_seconds = bot.data.settings.get("user_remove_seconds", {}).get(guild_id, {}).get(user_id, {}).get(role_name)
        default_seconds = bot.data.settings["remove_seconds"].get(role_name, DEFAULT_REMOVE_SECONDS[role_name])
        value = (
            f"**{format_duration(personal_seconds)}** (å€‹äººè¨­å®š)\nãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: {format_duration(default_seconds)}"
            if personal_seconds else f"{format_duration(default_seconds)} (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)"
        )
        embed.add_field(name=role_name, value=value, inline=True)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="sync_check", description="æ‰‹å‹•åŒæœŸãƒ»ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œï¼ˆç®¡ç†è€…é™å®šï¼‰")
@admin_required
async def sync_check(interaction: discord.Interaction):
    await interaction.response.defer(thinking=True)
    await sync_data_with_reality(interaction.guild)
    removed = await process_role_removal(interaction.guild)
    await bot.data.save_all()
    await interaction.followup.send(f"âœ… æ‰‹å‹•åŒæœŸå®Œäº†\nå‰Šé™¤ã•ã‚ŒãŸãƒ­ãƒ¼ãƒ«: {removed}å€‹")
    await log_message(interaction.guild, f"{interaction.user.display_name} ãŒæ‰‹å‹•åŒæœŸå®Ÿè¡Œ: {removed}å€‹å‰Šé™¤", "info")

@bot.tree.command(name="set_log_channel", description="ã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ãƒ­ã‚°é€ä¿¡å…ˆã«è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰")
@admin_required
async def set_log_channel(interaction: discord.Interaction):
    bot.data.guild_log_channels[str(interaction.guild.id)] = interaction.channel.id
    await bot.data.save_all()
    await interaction.response.send_message(f"âœ… ãƒ­ã‚°é€ä¿¡å…ˆã‚’ {interaction.channel.mention} ã«è¨­å®šã—ã¾ã—ãŸ", ephemeral=True)

@bot.tree.command(name="message", description="æŒ‡å®šã—ãŸãƒãƒ£ãƒ³ãƒãƒ«ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡")
@app_commands.describe(
    content="é€ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹",
    channel="é€ä¿¡å…ˆãƒãƒ£ãƒ³ãƒãƒ«ï¼ˆåå‰ã¾ãŸã¯IDã€çœç•¥æ™‚ã¯å®Ÿè¡Œã—ãŸãƒãƒ£ãƒ³ãƒãƒ«ï¼‰"
)
async def message_command(
    interaction: discord.Interaction,
    content: str,
    channel: str = None
):
    target_channel = None
    if channel:
        ch = discord.utils.get(interaction.guild.text_channels, name=channel)
        if ch:
            target_channel = ch
        else:
            try:
                channel_id = int(channel)
                ch = interaction.guild.get_channel(channel_id)
                if ch and ch.type == discord.ChannelType.text:
                    target_channel = ch
            except ValueError:
                pass
    if not target_channel:
        target_channel = interaction.channel
    if not target_channel.permissions_for(interaction.guild.me).send_messages:
        await interaction.response.send_message(
            f"âŒ {target_channel.mention} ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã§ãã¾ã›ã‚“ï¼ˆæ¨©é™ä¸è¶³ï¼‰",
            ephemeral=True
        )
        return
    try:
        await target_channel.send(content)
        await interaction.response.send_message(
            f"âœ… ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ {target_channel.mention} ã«é€ä¿¡ã—ã¾ã—ãŸ", ephemeral=True
        )
    except Exception as e:
        logger.error(f"Failed to send message: {e}")
        await interaction.response.send_message(
            f"âŒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}", ephemeral=True
        )

@bot.tree.command(name="help", description="ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§è¡¨ç¤º")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(title="ğŸ¤– ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§", color=0x0099ff)
    commands_info = {
        "/giveall": "å…¨å“¡ã«ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆç®¡ç†è€…é™å®šï¼‰",
        "/test_add": "è‡ªåˆ†ã«ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰",
        "/status": "BotçŠ¶æ…‹è¡¨ç¤º",
        "/set_remove_period": "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰",
        "/set_user_period": "å€‹äººå‰Šé™¤æœŸé–“è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰",
        "/show_user_period": "å€‹äººå‰Šé™¤æœŸé–“è¡¨ç¤º",
        "/show_role_history": "ãƒ­ãƒ¼ãƒ«ä»˜ä¸å±¥æ­´è¡¨ç¤ºï¼ˆæ³¨æ„ãƒ»è­¦å‘Šã®ã¿ã€‚ç†ç”±ç·¨é›†æ©Ÿèƒ½ä»˜ãï¼‰",
        "/sync_check": "æ‰‹å‹•åŒæœŸãƒ»ãƒã‚§ãƒƒã‚¯ï¼ˆç®¡ç†è€…é™å®šï¼‰",
        "/set_log_channel": "ã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ãƒ­ã‚°é€ä¿¡å…ˆã«è¨­å®šï¼ˆç®¡ç†è€…é™å®šï¼‰",
        "/message": "æŒ‡å®šã—ãŸãƒãƒ£ãƒ³ãƒãƒ«ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡"
    }
    for cmd, desc in commands_info.items():
        embed.add_field(name=cmd, value=desc, inline=False)
    embed.add_field(
        name="âš ï¸ é‡è¦äº‹é …",
        value=(
            "â€¢ è‡ªå‹•å‰Šé™¤å¯¾è±¡: " + ", ".join(ROLES_TO_AUTO_REMOVE) +
            "\nâ€¢ ä¸å®šæœŸèµ·å‹•å¯¾å¿œ"
            "\nâ€¢ å€‹äººåˆ¥å‰Šé™¤æœŸé–“è¨­å®šå¯èƒ½"
            "\nâ€¢ ãƒ­ãƒ¼ãƒ«ä»˜ä¸å±¥æ­´ç¢ºèªãƒ»ç†ç”±ç·¨é›†å¯èƒ½ï¼ˆæ³¨æ„ãƒ»è­¦å‘Šã®ã¿ï¼‰"
            "\nâ€¢ ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼ˆå„ãƒ­ãƒ¼ãƒ«5ä»¶ãšã¤è¡¨ç¤ºï¼‰"
            "\nâ€¢ ç†ç”±ç·¨é›†å¾Œã®è‡ªå‹•æ›´æ–°æ©Ÿèƒ½"
            "\nâ€¢ ãƒ­ã‚°é€ä¿¡å…ˆãƒãƒ£ãƒ³ãƒãƒ«ã‚’ã‚µãƒ¼ãƒãƒ¼ã”ã¨ã«è¨­å®šå¯èƒ½"
            "\nâ€¢ `/message` ã§å¥½ããªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä»»æ„ã®ãƒãƒ£ãƒ³ãƒãƒ«ã«æŠ•ç¨¿å¯èƒ½"
            "\n   ä¾‹: `/message Hello world! general`"
        ),
        inline=False
    )
    await interaction.response.send_message(embed=embed)

@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    logger.error(f"Application command error: {error}", exc_info=True)
    if not interaction.response.is_done():
        await interaction.response.send_message("âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", ephemeral=True)

TOKEN = os.environ.get("BOT_TOKEN")

if __name__ == "__main__":
    if not TOKEN:
        logger.error("BOT_TOKEN environment variable is not set")
        logger.error("ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¨­å®šã—ã¦ãã ã•ã„:")
        logger.error("  Windows: set BOT_TOKEN=ã‚ãªãŸã®ãƒˆãƒ¼ã‚¯ãƒ³")
        logger.error("  Mac/Linux: export BOT_TOKEN=ã‚ãªãŸã®ãƒˆãƒ¼ã‚¯ãƒ³")
        exit(1)
    try:
        logger.info("Starting bot...")
        bot.run(TOKEN)
    except discord.LoginFailure:
        logger.error("Invalid bot token")
        exit(1)
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        exit(1)
